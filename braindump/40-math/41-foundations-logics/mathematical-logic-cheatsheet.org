#+title: Mathematical Logic: A Historical Cheatsheet from Aristotle to Gödel
#+author: SOV710
#+date: <2025-12-27 Sat>
#+startup: showall
#+options: toc:2 num:nil

* 引子: 逻辑学的三次革命

数理逻辑的历史可以看作三次革命:

1. *亚里士多德* (前 4 世纪): 将推理形式化为三段论
2. *弗雷格* (1879): 发明谓词逻辑，用符号彻底取代自然语言
3. *哥德尔* (1931): 证明形式系统有根本限制

本文按历史发展脉络梳理核心概念，重点在于 *概念辨析* 而非技术细节。

* 第一阶段: 从亚里士多德到莱布尼茨 (前 4 世纪~17 世纪)

** 亚里士多德的三段论 (Syllogism)

*** 核心思想

推理可以分解为标准形式:

#+begin_example
大前提: 所有人都会死
小前提: 苏格拉底是人
结论:   苏格拉底会死
#+end_example

亚里士多德总结了 256 种三段论形式，其中只有 19 种是有效的 (valid)。

*** 三段论的四格 (Four Figures)

根据中词 (middle term, M) 在前提中的位置，分为四格:

| 格   | 大前提 | 小前提 | 示例              |
|-----+-------+-------+------------------|
| 第一格 | M-P   | S-M   | 所有 M 是 P, 所有 S 是 M |
| 第二格 | P-M   | S-M   | 所有 P 是 M, 没有 S 是 M |
| 第三格 | M-P   | M-S   | 所有 M 是 P, 所有 M 是 S |
| 第四格 | P-M   | M-S   | 所有 P 是 M, 所有 M 是 S |

*** 局限性

1. *只能处理主谓结构*: "所有 S 是 P" 这种形式
2. *无法表达关系*: "A 大于 B" 无法用三段论表示
3. *无法嵌套量词*: "每个人都爱某个人" 无法形式化

这些问题要等到弗雷格的谓词逻辑才解决。

** 莱布尼茨的梦想: Characteristica Universalis (1666)

*** 核心想法

莱布尼茨设想创造一种 *通用符号语言*，使得:

1. 所有概念都可以表示为符号
2. 所有推理都可以简化为 *符号计算* (calculus ratiocinator)
3. 哲学争论可以通过 "算一算" 解决

#+begin_quote
"如果有争议，学者们不需要再争论，只需拿起笔说: 让我们算一算 (Calculemus)！"
— 莱布尼茨
#+end_quote

*** 为什么失败了？

莱布尼茨没有成功的原因:

1. *没有形式化语法*: 符号系统不够严格
2. *没有区分语法和语义*: 混淆了符号操作和意义
3. *低估了逻辑的复杂性*: 谓词逻辑要到 200 年后才出现

但他的思想影响深远，直接启发了布尔和弗雷格。

* 第二阶段: 布尔代数与命题逻辑 (19 世纪)

** 乔治·布尔 (George Boole, 1854)

*** 核心贡献

布尔在《思维的规律》中将逻辑表示为 *代数运算*:

- $\land$ (AND): 逻辑乘法
- $\lor$ (OR): 逻辑加法
- $\neg$ (NOT): 逻辑补

*** 命题逻辑 (Propositional Logic)

*原子命题*: 不可再分的陈述，用 $P, Q, R$ 表示。

*逻辑联结词*:

| 符号      | 名称  | 真值条件                       |
|----------+------+-----------------------------|
| $\neg P$   | 否定  | $P$ 为假                      |
| $P \land Q$ | 合取  | $P$ 和 $Q$ 都为真                |
| $P \lor Q$  | 析取  | $P$ 或 $Q$ 至少一个为真            |
| $P \to Q$   | 蕴涵  | $P$ 为假或 $Q$ 为真 (等价于 $\neg P \lor Q$) |
| $P \leftrightarrow Q$ | 等价 | $P$ 和 $Q$ 同真或同假 |

*** 概念辨析: 蕴涵 vs. 因果

*重要*: $P \to Q$ *不是* "因为 $P$ 所以 $Q$"！

#+begin_example
"如果月亮是方的，那么 2+2=4"

在逻辑上这是真命题 (因为前件为假)
但在日常语言中毫无意义
#+end_example

这叫 *实质蕴涵* (material implication)，只关心真值表，不关心因果。

*** 局限性

命题逻辑无法表达:

1. *量词*: "所有人" vs. "某个人"
2. *变元*: "对于任意 $x$..."
3. *谓词*: "$x$ 是偶数"

这需要 *谓词逻辑*​。

* 第三阶段: 弗雷格革命与谓词逻辑 (1879~1930s)

** 戈特洛布·弗雷格 (Gottlob Frege, 1879)

*** 《概念文字》(Begriffsschrift, 1879)

弗雷格发明了 *谓词逻辑* (predicate logic / first-order logic)，彻底改变了逻辑学。

*** 核心创新

**** 1. 量词 (Quantifiers)

- *全称量词* $\forall$: "对于所有 $x$"
- *存在量词* $\exists$: "存在某个 $x$"

"所有人都会死"
符号化: $\forall x (Human(x) \to Mortal(x))$

"存在质数"
符号化: $\exists x (Prime(x))$

**** 2. 谓词 (Predicates)

谓词是 *命题函数*，接受变元返回真值:

- $Prime(x)$: "$x$ 是质数"
- $Greater(x, y)$: "$x$ 大于 $y$"
- $Loves(x, y)$: "$x$ 爱 $y$"

**** 3. 嵌套量词

可以表达复杂语句:

"每个人都爱某个人"
$\forall x \exists y \, Loves(x, y)$

"存在一个人被所有人爱"
$\exists y \forall x \, Loves(x, y)$

*注意*: 量词顺序很重要！交换顺序会改变意义。

*** 概念辨析: 一阶逻辑 vs. 高阶逻辑

**** 一阶逻辑 (First-Order Logic, FOL)

- 量词只能量化 *个体* (individuals)
- 不能量化谓词或函数

允许: $\forall x \, P(x)$  (对所有个体 $x$)
不允许: $\forall P \, P(a)$  (对所有谓词 $P$)

**** 高阶逻辑 (Higher-Order Logic, HOL)

- 量词可以量化谓词、函数等

$\forall P (\forall x \, P(x) \to P(a))$
意思: "如果性质 $P$ 对所有 $x$ 成立，那么 $P(a)$ 成立"

*为什么一阶逻辑更常用？*

- 一阶逻辑有完备性和可判定性的好性质 (见后文)
- 高阶逻辑过于强大，失去了很多好性质

** 罗素悖论 (Russell's Paradox, 1901)

*** 集合论的灾难

弗雷格试图用逻辑建立数学基础，定义了 *概括公理*:

#+begin_quote
对于任意性质 $P$，存在集合 $\{x \mid P(x)\}$ 包含所有满足 $P$ 的元素。
#+end_quote

罗素发现这导致矛盾:

设 $R = \{x \mid x \notin x\}$  (不包含自己的集合)

问: $R \in R$ 吗？

- 如果 $R \in R$，根据定义 $R \notin R$  (矛盾！)
- 如果 $R \notin R$，根据定义 $R \in R$  (矛盾！)

*** 理发师悖论 (通俗版本)

#+begin_quote
某村有个理发师，他只给 "不给自己理发的人" 理发。

问: 谁给理发师理发？

- 如果他给自己理发，那么他不应该给自己理发 (矛盾)
- 如果他不给自己理发，那么他应该给自己理发 (矛盾)
#+end_quote

*** 解决方案: 类型论和公理化集合论

**** 罗素的类型论 (Type Theory, 1908)

禁止 "$x \in x$" 这种自指:

- 个体 (individuals): 类型 0
- 个体的集合: 类型 1
- 集合的集合: 类型 2
- ...

规则: $x \in y$ 只有在 $x$ 的类型比 $y$ 低时才合法。

*缺点*: 过于复杂，限制太强。

**** 策梅洛-弗兰克尔集合论 (ZFC, 1920s)

用公理系统限制集合的构造，避免悖论。核心公理:

- *外延公理*: 集合由元素决定
- *配对公理*: 可以构造 $\{a, b\}$
- *分离公理*: 从已有集合中分离子集 (取代概括公理)
- *无穷公理*: 存在无穷集合
- *选择公理* (Axiom of Choice, AC): 最有争议的公理

*ZFC 成为现代数学的标准基础*​。

* 第四阶段: 希尔伯特纲领与形式系统 (1920s)

** 大卫·希尔伯特 (David Hilbert)

*** 希尔伯特纲领 (Hilbert's Program)

希尔伯特的目标:

1. *形式化*: 将数学表示为形式系统 (符号 + 推导规则)
2. *完备性*: 所有真命题都可以证明
3. *一致性*: 系统不会证明矛盾
4. *可判定性*: 存在算法判断任意命题的真假

*** 形式系统的三要素

**** 1. 语法 (Syntax)

- *符号表* (Alphabet): 基本符号，如 $\forall, \exists, \land, \to, 0, S, +, \times$
- *公式* (Formulas): 符号的合法组合
- *句子* (Sentences): 不含自由变元的公式

*示例*:

$\forall x (x + 0 = x)$  是句子
$x + 0 = x$  是公式但不是句子 ($x$ 自由)

**** 2. 公理 (Axioms)

- *逻辑公理*: 对所有解释都成立，如 $P \to (Q \to P)$
- *非逻辑公理*: 特定理论的假设，如 Peano 公理 (算术)

**** 3. 推导规则 (Inference Rules)

- *分离规则* (Modus Ponens): 从 $P$ 和 $P \to Q$ 推出 $Q$
- *全称推广*: 从 $\varphi(x)$ 推出 $\forall x \, \varphi(x)$ (若 $x$ 任意)

*** 概念辨析: 可证 vs. 真

*这是数理逻辑最容易混淆的点*。

**** 可证 (Provable)

$\vdash \varphi$ 表示 "$\varphi$ 可以从公理通过推导规则得到"。

- 这是 *语法* 概念，纯符号操作
- 不涉及 "意义"

**** 真 (True)

$\models \varphi$ 表示 "$\varphi$ 在给定解释下为真"。

- 这是 *语义* 概念，需要赋予符号意义

*示例*:

形式系统: 只有公理 $P$，推导规则是分离规则

$\vdash P$  (可证，$P$ 是公理)
$\vdash P \to Q$？  (不可证，没有公理或规则能得到它)

但我们可以选择一个解释让 $P \to Q$ 为真，比如:
- $P$ 解释为 "真"
- $Q$ 解释为 "真"
- 那么 $P \to Q$ 也是真的

所以 $\models P \to Q$ 在这个解释下成立，但 $\nvdash P \to Q$

*** 可靠性和完备性

**** 可靠性 (Soundness)

#+begin_quote
如果 $\vdash \varphi$，那么 $\models \varphi$
#+end_quote

意思: *能证明的都是真的*。

- 这保证系统不会证明假命题
- 几乎所有有用的形式系统都是可靠的

**** 完备性 (Completeness)

#+begin_quote
如果 $\models \varphi$，那么 $\vdash \varphi$
#+end_quote

意思: *真的都能证明*​。

- 这是希尔伯特纲领的核心目标
- 哥德尔 1929 年证明了 *一阶逻辑* 是完备的 (哥德尔完备性定理)
- 但 1931 年又证明了 *算术* 不完备 (哥德尔不完备性定理)

** 哥德尔完备性定理 (Gödel's Completeness Theorem, 1929)

*** 定理内容

#+begin_quote
一阶逻辑是完备的: 如果 $\models \varphi$，那么 $\vdash \varphi$。
#+end_quote

*** 意义

- 一阶逻辑的 "语法" 和 "语义" 完全吻合
- 这是 *好消息*: 一阶逻辑是 "完美" 的逻辑系统

*** 证明思路

哥德尔构造了一个 *标准模型* (canonical model):

1. 假设 $\nvdash \varphi$ (不可证)
2. 那么 $\neg \varphi$ 和公理集是一致的 (consistent)
3. 构造一个模型使 $\neg \varphi$ 为真
4. 所以 $\nvDash \varphi$ (不恒真)

* 第五阶段: 哥德尔不完备性定理与可计算性 (1930s)

** 哥德尔第一不完备性定理 (Gödel's First Incompleteness Theorem, 1931)

*** 定理内容

#+begin_quote
任何 *一致的*、*足够强* 的形式系统 $T$，都存在命题 $G$ 使得:

$\nvdash_T G$ 且 $\nvdash_T \neg G$

即: $G$ 既不可证也不可反驳 (*不可判定*, undecidable)。

而且，$G$ 在标准解释下是 *真* 的！
#+end_quote

*** 关键条件

**** 一致的 (Consistent)

系统不会同时证明 $\varphi$ 和 $\neg \varphi$。

*如果不一致*: 可以证明任何命题 (爆炸原理)，系统无意义。

**** 足够强 (Sufficiently Strong)

能够表达基本的算术，如 Peano 算术 (PA)。

*具体要求*: 能定义加法、乘法，能表达 "可计算性"。

*** 证明思路: 哥德尔编码

哥德尔的天才之处在于让形式系统 "谈论自己"。

**** 1. 哥德尔配数 (Gödel Numbering)

将符号、公式、证明都编码为自然数:

#+begin_example
符号 '0' → 1
符号 'S' (后继) → 2
符号 '+' → 3
符号 '=' → 4
...

公式 '0 = 0' → $2^1 \cdot 3^4 \cdot 5^1 = 150$  (质数幂编码)
#+end_example

*关键*: 编码是可计算的，且可以 *在形式系统内定义*。

**** 2. 构造自指命题

定义谓词 $Prov(x)$: "$x$ 是可证命题的哥德尔数"。

构造命题 $G$:

#+begin_quote
$G$ 说: "哥德尔数为 $\ulcorner G \urcorner$ 的命题不可证"
#+end_quote

形式化:

$$G \equiv \neg Prov(\ulcorner G \urcorner)$$

*这是形式化的 "我不可证"！*

**** 3. 推理

假设 $\vdash G$:

- 那么 $G$ 可证
- 但 $G$ 说自己不可证
- 矛盾！所以 $\nvdash G$

既然 $\nvdash G$，那么 $G$ 的陈述是 *真* 的: "我确实不可证"。

如果系统一致，就不能证明 $\neg G$ (否则矛盾)。

所以 $G$ 既不可证也不可反驳！

*** 概念辨析: 不完备 vs. 不一致

- *不完备*: 存在真命题无法证明
- *不一致*: 可以同时证明 $\varphi$ 和 $\neg \varphi$

哥德尔定理说: *一致 → 不完备* (对足够强的系统)。

你只能二选一:

- 要么系统一致但不完备 (有真理无法证明)
- 要么系统完备但不一致 (能证明所有命题，包括矛盾)

*一致性比完备性更重要*，所以我们接受不完备。

** 哥德尔第二不完备性定理 (1931)

*** 定理内容

#+begin_quote
如果系统 $T$ 一致，那么 $T$ 无法证明自己的一致性。
#+end_quote

*** 形式化

设 $Con(T)$ 表示 "$T$ 一致"，那么:

$$\text{如果 } T \text{ 一致, 则 } \nvdash_T Con(T)$$

*** 意义

- 希尔伯特纲领破产: 无法用有穷方法证明算术的一致性
- 数学基础永远需要 "信仰": 我们相信 PA 一致，但无法证明

** 图灵机与可计算性 (Alan Turing, 1936)

*** 停机问题 (Halting Problem)

*问题*: 是否存在算法，输入任意程序 $P$ 和输入 $x$，判断 $P(x)$ 会停机还是无限循环？

*答案*: *不存在*！

*** 证明 (对角线论证)

假设存在停机判定器 $H(P, x)$:

- 返回 =true= 如果 $P(x)$ 停机
- 返回 =false= 如果 $P(x)$ 不停机

构造程序 $D$:

#+begin_src python
def D(P):
    if H(P, P):  # 如果 P(P) 停机
        while True: pass  # 那么无限循环
    else:
        return  # 否则停机
#+end_src

问: $D(D)$ 停机吗？

- 如果 $D(D)$ 停机，那么 $H(D, D) = \text{true}$，所以 $D(D)$ 无限循环 (矛盾)
- 如果 $D(D)$ 不停机，那么 $H(D, D) = \text{false}$，所以 $D(D)$ 停机 (矛盾)

所以 $H$ 不存在！

*** Church-Turing 论题

#+begin_quote
直觉上 "可计算" 的函数，恰好是 *图灵可计算* 的函数。
#+end_quote

这不是定理 (因为 "直觉上可计算" 不是严格定义)，而是一个 *论题*。

但几乎所有数学家都接受，因为:

- 图灵机、λ-演算、递归函数等所有计算模型都等价
- 从未发现 "可计算但图灵机算不了" 的例子

*** 可计算性与不完备性的联系

- *哥德尔*: 真理 ≠ 可证明性
- *图灵*: 真理 ≠ 可计算性

两者深刻相关: 哥德尔编码本质上是用 *可计算函数* 编码证明。

* 第六阶段: 模型论与证明论 (1950s~)

** 模型论 (Model Theory)

*** 核心问题

研究 *公式与结构的关系*。

*结构* (structure) 是一个三元组 $\mathcal{M} = (M, I, \rho)$:

- $M$: 论域 (domain, 个体的集合)
- $I$: 解释函数 (给符号赋予意义)
- $\rho$: 变元赋值

*示例*:

符号: 常量 $0$, 函数 $S$, 谓词 $<$
公式: $\forall x (x < S(x))$

结构 1: 自然数
- $M = \mathbb{N}$
- $I(0) = 0, I(S) = n \mapsto n+1, I(<) = \text{小于关系}$
- $\mathcal{M}_1 \models \forall x (x < S(x))$  ✓ (真)

结构 2: 整数模 5
- $M = \{0, 1, 2, 3, 4\}$
- $I(S) = n \mapsto (n+1) \mod 5$
- $\mathcal{M}_2 \nvDash \forall x (x < S(x))$  ✗ (假，因为 $4 < 0$ 不成立)

*** 概念辨析: 标准模型 vs. 非标准模型

*标准模型*: 符号的 "本意" 解释。

Peano 算术的标准模型: 自然数 $\mathbb{N}$

*非标准模型*: 其他满足公理的解释。

Peano 算术有无穷多个非标准模型，包含 "超限自然数"
- 存在元素 $\omega > n$ 对所有有限 $n$
- 但仍满足所有 Peano 公理！

这是 Skolem 悖论的来源: ZFC 集合论虽然想描述 "所有集合"，但有可数模型 (Löwenheim-Skolem 定理)。

** 证明论 (Proof Theory)

*** 核心问题

研究 *证明本身的结构*，不依赖语义。

*重要工具*:

- *自然演绎* (Natural Deduction): Gentzen 1935
- *相继式演算* (Sequent Calculus): Gentzen 1935
- *切消定理* (Cut Elimination): 证明可以标准化

*** 概念辨析: 证明 vs. 推导

*推导* (derivation): 从公理到定理的符号序列。

#+begin_example
公理 1: $A \to (B \to A)$
公理 2: $(A \to (B \to C)) \to ((A \to B) \to (A \to C))$
推导规则: Modus Ponens

推导:
1. $A \to (B \to A)$  [公理 1]
2. ...
#+end_example

*证明* (proof): 更抽象的概念，可能是:

- 语义证明 (用真值表、模型)
- 非形式证明 (数学家写的证明)

形式系统中，"证明" 通常指 "推导"。

** 直觉主义逻辑 (Intuitionistic Logic)

*** 核心思想

拒绝 *排中律* (Law of Excluded Middle, LEM):

$$\varphi \lor \neg \varphi$$

*原因*: 直觉主义认为 "真" 等于 "可构造性证明"。

经典逻辑: "$\exists x \, P(x)$" 只需证明 "不是所有 $x$ 都满足 $\neg P(x)$"

直觉主义: 必须 *构造* 出具体的 $x$ 并证明 $P(x)$

*** BHK 解释 (Brouwer-Heyting-Kolmogorov)

- $P \land Q$ 的证明 = $P$ 的证明 + $Q$ 的证明
- $P \lor Q$ 的证明 = $P$ 的证明或 $Q$ 的证明 (需标记是哪个)
- $P \to Q$ 的证明 = 将 $P$ 的证明转换为 $Q$ 的证明的 *算法*
- $\exists x \, P(x)$ 的证明 = 具体的 $x$ + $P(x)$ 的证明

*** Curry-Howard 同构

#+begin_quote
*证明 = 程序，命题 = 类型*
#+end_quote

| 逻辑                | 类型论              | 编程             |
|---------------------+--------------------+------------------|
| $P \land Q$         | =P * Q=              | 元组类型 =(P, Q)=   |
| $P \lor Q$          | =P + Q=              | 和类型 =Either P Q= |
| $P \to Q$           | =P -> Q=             | 函数类型          |
| $\forall x \, P(x)$ | 依赖类型 $\Pi$ 类型    | 泛型 =<T> -> P(T)= |
| $\exists x \, P(x)$ | 依赖对 $\Sigma$ 类型   | 存在类型          |

*示例*:

#+begin_src haskell
-- 命题: A ∧ B → B ∧ A
swap :: (a, b) -> (b, a)
swap (x, y) = (y, x)

-- 这是 "交换律" 的构造性证明
#+end_src

依赖类型语言 (Coq, Agda, Lean) 就是基于这个同构！

* 现代发展与应用

** 模态逻辑 (Modal Logic)

引入 *可能* ($\Diamond$) 和 *必然* ($\Box$) 算子。

$\Box P$: "$P$ 必然真" (在所有可能世界中为真)
$\Diamond P$: "$P$ 可能真" (在某个可能世界中为真)

*应用*:

- 时态逻辑 (Temporal Logic): 软件验证
- 认知逻辑 (Epistemic Logic): 知识表示
- 可证性逻辑 (Provability Logic): 研究证明本身

** 线性逻辑 (Linear Logic, Girard 1987)

区分 *资源* 和 *真值*​。

经典逻辑: $P \land P \to P$  (幂等性)
线性逻辑: 两个 $P$ 和一个 $P$ 不同 (两块钱 ≠ 一块钱)

*应用*: 并发编程、量子计算、游戏语义。

** 自动定理证明 (Automated Theorem Proving)

*** SAT 求解器

判定命题逻辑的可满足性。

*应用*: 硬件验证、调度问题、密码分析。

*** SMT 求解器 (Satisfiability Modulo Theories)

扩展 SAT 到算术、数组、位向量等理论。

*工具*: Z3, CVC5, Yices

*** 交互式证明助手

- *Coq*: 数学形式化 (四色定理、Feit-Thompson 定理)
- *Lean*: 数学库 Mathlib (本科到研究生数学)
- *Isabelle/HOL*: 软件验证

** 可计算性理论的分支

*** 递归论 (Recursion Theory)

研究 *计算的层次*:

- 可计算集合 (recursive sets)
- 递归可枚举集合 (r.e. sets)
- 算术层次 (arithmetic hierarchy)
- 图灵度 (Turing degrees)

*** 复杂性理论 (Complexity Theory)

研究 *计算的效率*:

- P: 多项式时间可解
- NP: 非确定性多项式时间可解
- P vs. NP: 千禧年难题

*** 描述复杂性 (Descriptive Complexity)

逻辑复杂性 = 计算复杂性:

- FO (一阶逻辑) = AC^0 (常数深度电路)
- SO (二阶逻辑) = PH (多项式层次)
- FO + LFP (最小不动点) = P

* 总结: 数理逻辑的核心教训

** 1. 形式化不是万能的

莱布尼茨的梦想破灭了:

- 哥德尔: 真理 > 可证明性
- 图灵: 真理 > 可计算性

*数学永远需要非形式的直觉和创造力。*

** 2. 自指是深刻的

所有重大结果都涉及自指:

- 罗素悖论: 集合谈论自己
- 哥德尔定理: 公式谈论自己的可证性
- 停机问题: 程序判断自己是否停机

*自指是逻辑的边界。*

** 3. 语法与语义的张力

- 语法: 符号操作，机械可行
- 语义: 意义解释，涉及 "真理"

两者的关系是数理逻辑的永恒主题:

- 可靠性: 语法 → 语义
- 完备性: 语义 → 语法

** 4. 选择你的逻辑

不存在 "唯一正确" 的逻辑:

- 经典逻辑: 数学主流
- 直觉主义逻辑: 构造性数学、程序验证
- 线性逻辑: 资源敏感
- 模态逻辑: 时间、知识、可能性

*逻辑是工具，根据需求选择。*

** 5. 限制即力量

一阶逻辑的成功在于它 *足够弱*:

- 完备性 ✓
- 紧致性 ✓
- Löwenheim-Skolem 性质 ✓

高阶逻辑更强大，但失去了这些好性质。

*在表达力和可控性之间权衡。*

-----

*数理逻辑告诉我们: 理性有边界，但在边界之内，我们可以走得很远。*
