#+title: Taskwarrior CLI Deep Dive: From Syntax to Semantic Understanding
#+author: SOV710
#+date: 2025-12-22
#+startup: showall
#+options: toc:2 num:nil

* 命令行语法的本质

Taskwarrior 的命令行语法乍一看是一堆参数的堆砌，但其实有着清晰的结构。理解这个结构是用好 Taskwarrior 的前提。

** 通用语法形式

#+begin_src sh
task [<filter>] <command> [<modifications>]
#+end_src

这三个部分各司其职:

| 段              | 本质                       |
|-----------------+----------------------------|
| =<filter>=        | 一个查询表达式，用于选中任务集合 |
| =<command>=       | 对集合执行的操作或报告         |
| =<modifications>= | 对集合中每个任务施加的字段修改   |

*关键点*: 这三个部分都是 *可选的*​。如果不指定 command，Taskwarrior 会使用默认命令 (由 =default.command= 配置项决定，通常是 =next=)。

** 顺序无关的 Overrides

除了这三个核心部分，命令行上还可以出现 *临时配置覆盖* (runtime overrides):

#+begin_src sh
task rc.verbose=nothing project:Home list
task list rc.defaultwidth=120 project:Home
#+end_src

这些 =rc.*= 参数可以出现在命令行的 *任何位置*，因为它们在命令执行前就被处理了，不参与 filter/command/modifications 的语法解析。

这是个非常强大的特性，允许你为单次命令临时修改配置，而不影响 =~/.taskrc= 文件:

#+begin_src sh
# 使用另一个任务数据库
task rc.data.location=/tmp/alt-tasks list

# 强制彩色输出 (即使输出到管道)
task rc._forcecolor:on rc.defaultwidth:120 next

# 临时关闭正则表达式
task rc.regex:off /pattern/ list
#+end_src

* Filter: 查询表达式的代数本质

Filter 是 Taskwarrior 最核心的概念，它决定了哪些任务会被选中。

** Filter 的本质: 布尔代数表达式

一个 filter 本质上是一个 *布尔表达式*，对每个任务求值，返回 true (匹配) 或 false (不匹配)。

例子:

#+begin_src sh
task project:kernel +bug due.before:today
#+end_src

在内部等价于:

#+begin_example
从 task 数据集中，选出满足:
- project == "kernel"
- tags 包含 "bug"
- due < today()
的任务集合
#+end_example

*** 隐式的 AND 连接

当 filter 中有多个项时，默认是 *逻辑与* (AND) 连接:

#+begin_src sh
task project:Home +work priority:H
#+end_src

等价于:

#+begin_src sh
task project:Home and +work and priority:H
#+end_src

这是个命令行语法的简写，减少打字量。

*** 显式的逻辑运算符

Taskwarrior 支持三种逻辑运算符:

- =and= (逻辑与)
- =or= (逻辑或)
- =xor= (异或)

以及括号 =(...)= 用于控制优先级:

#+begin_src sh
# 家庭项目 OR 没有 work 标签
task project:Home or -work count

# 复杂表达式
task \( project:Home or project:Garden \) and +weekend list
#+end_src

*注意*: 括号在 shell 中有特殊含义，必须转义:

#+begin_src sh
# 方法 1: 反斜杠转义
task \( project:Home or project:Garden \) list

# 方法 2: 单引号
task '(project:Home or project:Garden)' list

# 方法 3: 双引号
task "(project:Home or project:Garden)" list
#+end_src

** Filter 的语法形式

*** 1. 属性匹配: =attribute:value=

最常见的 filter 形式，匹配属性值:

#+begin_src sh
task project:kernel          # project == "kernel"
task status:pending          # status == "pending"
task priority:H              # priority == "H"
#+end_src

*空值匹配*:

#+begin_src sh
task project:                # 没有 project 的任务
task priority.none:          # 没有 priority 的任务
#+end_src

*** 2. 属性修饰符: =attribute.modifier:value=

修饰符提供了更精细的控制:

| 修饰符                      | 示例                     | 等价于          | 含义                 |
|-------------------------+------------------------+----------------+---------------------|
| =not=                     | =due.not:today=          | =due != today=   | 模糊非匹配           |
| =before=, =below=          | =due.before:today=       | =due < today=    | 精确日期比较         |
| =after=, =above=           | =due.after:today=        | =due >= tomorrow= | 精确日期比较         |
| =none=                    | =project.none:=          | =project == ''=  | 空值                |
| =any=                     | =project.any:=           | =project !== ''= | 非空值              |
| =is=, =equals=             | =project.is:Home=        | =project == Home= | 精确匹配            |
| =isnt=                    | =project.isnt:Home=      | =project !== Home= | 精确非匹配          |
| =has=, =contains=          | =desc.has:Hello=         | =desc ~ "Hello"= | 模式匹配 (正则)      |
| =hasnt=                   | =desc.hasnt:Hello=       | =desc !~ "Hello"= | 模式非匹配          |
| =startswith=, =left=       | =desc.left:Fix=          | =desc ~ '^Fix'=  | 起始匹配            |
| =endswith=, =right=        | =desc.right:bug=         | =desc ~ 'bug$'=  | 结尾匹配            |
| =word=                    | =desc.word:TODO=         | =desc ~ '\bTODO\b'= | 单词边界匹配        |
| =noword=                  | =desc.noword:TODO=       | =desc !~ '\bTODO\b'= | 单词边界非匹配      |

示例:

#+begin_src sh
# 所有 due date 在今天之前的任务
task due.before:today list

# description 包含 "meeting" (大小写不敏感)
task desc.has:meeting list

# project 名以 "Work." 开头的任务
task project.startswith:Work. list

# 没有 priority 的任务
task priority.none: list
#+end_src

*** 3. 标签过滤: =+tag= / =-tag=

标签是 Taskwarrior 中最简洁的 filter 语法:

#+begin_src sh
task +work             # 有 work 标签的任务
task -home             # 没有 home 标签的任务
task +work -home       # 有 work 但没有 home 标签
#+end_src

这比 =tags.has:work= 简洁太多。

*** 4. 描述搜索: =/pattern/=

正则表达式搜索 (搜索 description 和 annotations):

#+begin_src sh
task /bug/             # description 或 annotation 包含 "bug"
task /^Fix/            # description 以 "Fix" 开头
task /meeting|call/    # 包含 "meeting" 或 "call"
#+end_src

*大小写控制*:

#+begin_src sh
# 默认大小写不敏感
task rc.search.case.sensitive:yes /Pattern/ list

# 强制不敏感
task rc.search.case.sensitive:no /PATTERN/ list
#+end_src

*注意*: 正则表达式支持可以通过 =rc.regex= 配置关闭:

#+begin_src sh
task config regex off
#+end_src

*** 5. ID 范围: =<id>= / =<id>-<id>=

选择特定 ID 或 ID 范围:

#+begin_src sh
task 12                # 任务 12
task 1-10              # 任务 1 到 10
task 1,5,8             # 任务 1, 5, 8
task 1-10,15,20-25     # 组合范围
#+end_src

*** 6. UUID: =<uuid>=

使用任务的 UUID (全局唯一标识符):

#+begin_src sh
task 550e8400-e29b-41d4-a716-446655440000 info
#+end_src

UUID 是 Taskwarrior 内部用于同步和跨设备识别任务的关键。

*** 7. 虚拟标签 (Virtual Tags)

虚拟标签是 Taskwarrior 内置的 "伪标签"，它们在运行时动态计算，不占用存储空间:

| 虚拟标签      | 含义                           |
|-------------+--------------------------------|
| =+PENDING=    | status:pending                 |
| =+COMPLETED=  | status:completed               |
| =+DELETED=    | status:deleted                 |
| =+BLOCKED=    | 被其他任务阻塞                 |
| =+UNBLOCKED=  | 未被阻塞 (等价于 =-BLOCKED=)   |
| =+BLOCKING=   | 阻塞其他任务                   |
| =+READY=      | 可以开始工作的任务             |
| =+OVERDUE=    | 已过期                         |
| =+TODAY=      | 今天到期                       |
| =+TOMORROW=   | 明天到期                       |
| =+WEEK=       | 本周到期                       |
| =+MONTH=      | 本月到期                       |
| =+YEAR=       | 今年到期                       |
| =+ACTIVE=     | 正在进行中 (start 已设置)      |
| =+SCHEDULED=  | 已计划 (scheduled 已设置)      |
| =+PARENT=     | 是循环任务的父任务             |
| =+CHILD=      | 是循环任务的子任务             |
| =+UNTIL=      | 有过期时间                     |
| =+WAITING=    | 处于等待状态                   |
| =+ANNOTATED=  | 有 annotation                  |
| =+TAGGED=     | 有任意标签                     |
| =+PROJECT=    | 有 project                     |
| =+PRIORITY=   | 有 priority                    |
| =+DUE=        | 有 due date                    |
| =+DUETODAY=   | 今天到期 (等价于复杂 filter)   |
| =+ORPHAN=     | 孤儿任务 (没有 project)        |

示例:

#+begin_src sh
# 今天到期的任务 (简洁版)
task +DUETODAY list

# 传统复杂版本
task due.after:yesterday and due.before:tomorrow list

# 未被阻塞且可以开始的任务
task +READY list

# 所有已过期的任务
task +OVERDUE list
#+end_src

虚拟标签极大地简化了常见查询。

** Report Filter: 内置 Filter

每个 report (如 =list=, =next=) 都有一个 *内置 filter*，会与命令行的 filter 组合:

#+begin_src sh
# 查看 list report 的内置 filter
task show report.list.filter

# 输出
report.list.filter=status:pending
#+end_src

这意味着当你运行:

#+begin_src sh
task project:Home list
#+end_src

实际执行的 filter 是:

#+begin_src sh
task status:pending and project:Home list
#+end_src

这就是为什么 =list= 默认不显示已完成任务的原因。

*覆盖 report filter*:

如果你想看到所有任务 (包括已完成)，需要使用没有内置 filter 的 report:

#+begin_src sh
task project:Home all
#+end_src

或者临时修改 report filter:

#+begin_src sh
task rc.report.list.filter='' project:Home list
#+end_src

** 空 Filter: 匹配所有任务

最简单的 filter 是空 filter，匹配所有任务:

#+begin_src sh
task count       # 显示所有任务数量 (pending + completed)
task all         # 显示所有任务
#+end_src

* Command: 操作还是报告

Command 决定了对选中的任务集合做什么操作。Taskwarrior 的 command 分为两大类: *修改命令* (mutating) 和 *报告命令* (reporting)。

** 第一类: Mutating Commands (改变数据)

这些命令会 *修改任务数据库*:

| 命令         | 语义                      | 示例                                    |
|------------+---------------------------+----------------------------------------|
| =add=        | 创建新任务                | =task add Fix the bug=                 |
| =modify=     | 修改字段                  | =task 12 modify priority:H=            |
| =done=       | 标记为完成 (status:completed) | =task 12 done=                        |
| =delete=     | 删除任务 (status:deleted) | =task 12 delete=                       |
| =start=      | 开始任务 (设置 start 字段) | =task 12 start=                        |
| =stop=       | 停止任务 (清除 start 字段) | =task 12 stop=                         |
| =annotate=   | 添加注释                  | =task 12 annotate "Progress update"=   |
| =denotate=   | 删除注释                  | =task 12 denotate "Old note"=          |
| =append=     | 追加到 description        | =task 12 append "more details"=        |
| =prepend=    | 前置到 description        | =task 12 prepend "URGENT: "=           |
| =duplicate=  | 复制任务                  | =task 12 duplicate=                    |

*** =add= 命令

创建新任务时，可以直接指定属性:

#+begin_src sh
task add Fix the memory leak project:kernel priority:H due:friday +bug
#+end_src

*多行 description*:

#+begin_src sh
task add "Line 1
> Line 2
> Line 3"
#+end_src

*** =modify= 命令

Modify 是最灵活的命令，可以修改任意字段:

#+begin_src sh
# 修改单个任务
task 12 modify priority:H due:tomorrow

# 修改多个任务 (使用 filter)
task +bug project:kernel modify priority:H

# 清空字段
task 12 modify priority:        # 清空 priority
task 12 modify due:              # 清空 due date
#+end_src

*** =done= 和 =delete= 的区别

- =done=: 将任务标记为 =status:completed=，保留在数据库中，可以在 =completed= report 中看到
- =delete=: 将任务标记为 =status:deleted=，只能通过 =task all= 看到，或者用 =rc.report.all.filter= 修改

*恢复已删除的任务*:

#+begin_src sh
# 查看已删除任务
task status:deleted list

# 恢复
task <uuid> modify status:pending
#+end_src

*** =start= 和 =stop=

Taskwarrior 支持 "活动任务" (active task) 的概念:

#+begin_src sh
# 开始任务 (设置 start 时间戳)
task 12 start

# 停止任务 (清除 start)
task 12 stop

# 查看当前活动任务
task +ACTIVE list
#+end_src

一次只能有一个任务处于 active 状态 (可以配置允许多个)。

*** =annotate= 命令

Annotations 是任务的附加备注，带时间戳:

#+begin_src sh
# 添加 annotation
task 12 annotate "Discussed with team, agreed on approach"

# 查看
task 12 info

# 删除 (需要匹配完整文本或部分文本)
task 12 denotate "Discussed"
#+end_src

Annotations 在 urgency 计算中有微弱的贡献 (系数 1.0)，表示任务的活跃度。

** 第二类: Reporting Commands (只读)

报告命令 *不修改数据*，只是以不同方式展示任务:

| 命令      | 本质                | 内置 filter                        | 排序                |
|-----------+---------------------+------------------------------------+---------------------|
| =list=      | 标准待办事项列表       | =status:pending=                     | urgency 降序        |
| =next=      | 最紧急的任务 (默认命令) | =status:pending -WAITING=            | urgency 降序，限 1 页 |
| =long=      | 详细列表             | =status:pending=                     | urgency 降序        |
| =all=       | 所有任务 (无 filter)  | (空)                               | ID 升序             |
| =completed= | 已完成任务            | =status:completed=                   | end 降序            |
| =recurring= | 循环任务             | =status:recurring=                   | -                   |
| =waiting=   | 等待中的任务          | =status:waiting=                     | -                   |
| =blocked=   | 被阻塞的任务          | =+BLOCKED=                           | urgency 降序        |
| =blocking=  | 阻塞其他任务的任务     | =+BLOCKING=                          | urgency 降序        |
| =overdue=   | 已过期任务            | =+OVERDUE=                           | urgency 降序        |
| =ready=     | 可以开始的任务         | =+READY=                             | urgency 降序        |
| =projects=  | 项目列表             | -                                  | -                   |
| =tags=      | 标签列表             | -                                  | -                   |
| =summary=   | 汇总统计             | (可自定义)                          | -                   |
| =burndown=  | 燃尽图               | =status:pending or status:completed= | -                   |

*** 报告的本质: 配置的组合

*关键认知*: =list=, =next=, =long= 等 *不是硬编码的命令*，而是 *预定义的报告* (report)。

每个 report 本质上是一组配置项的集合:

#+begin_src sh
# 查看 next report 的配置
task show report.next

# 输出
report.next.columns      = id,start.age,entry.age,depends,priority,project,tags,recur,scheduled.countdown,due.relative,until.remaining,description,urgency
report.next.description  = Most urgent tasks
report.next.filter       = status:pending limit:page -WAITING
report.next.labels       = ID,Active,Age,Deps,P,Project,Tag,Recur,S,Due,Until,Description,Urg
report.next.sort         = urgency-
#+end_src

这意味着:

- =columns=: 显示哪些列
- =filter=: 内置 filter
- =sort=: 排序规则 (=urgency-= 表示按 urgency 降序)
- =labels=: 列标题

*自定义报告*:

你可以创建自己的 report:

#+begin_src sh
# 定义一个 "today" report，显示今天到期的任务
task config report.today.description "Tasks due today"
task config report.today.filter "+DUETODAY status:pending"
task config report.today.columns "id,project,priority,description,urgency"
task config report.today.labels "ID,Project,Pri,Description,Urg"
task config report.today.sort "urgency-"

# 使用
task today
#+end_src

*** =next= 是默认 report

当你只输入 =task= 时，默认执行 =next= report (除非你修改了 =default.command=):

#+begin_src sh
task                # 等价于 task next
task project:Home   # 等价于 task project:Home next
#+end_src

*** =export= 和 =import=: JSON 格式

Taskwarrior 的数据是 JSON 格式，可以导出/导入:

#+begin_src sh
# 导出为 JSON
task export > tasks.json

# 导出特定任务
task project:kernel +bug export > kernel-bugs.json

# 导入
task import tasks.json
#+end_src

这是编写扩展脚本和与其他工具集成的基础。

*** =info= 命令: 查看任务详情

#+begin_src sh
task 12 info
#+end_src

显示任务的所有属性，包括:

- UUID
- 创建时间 (entry)
- 最后修改时间 (modified)
- Urgency 分数及其计算细节
- 依赖关系
- Annotations

这是调试和理解 urgency 计算的重要工具。

** 第三类: 其他命令

还有一些辅助命令:

| 命令        | 功能                   |
|-------------+------------------------|
| =show=        | 显示配置                |
| =config=      | 修改配置                |
| =diagnostics= | 诊断信息 (版本、路径、依赖) |
| =sync=        | 同步到 Taskserver       |
| =undo=        | 撤销上一次操作            |
| =help=        | 帮助信息                |
| =version=     | 版本号                  |
| =calc=        | 日期计算器               |

*** =undo= 命令

Taskwarrior 会记录所有操作历史，可以撤销:

#+begin_src sh
# 撤销上一次操作
task undo

# 查看操作历史
ls ~/.task/*.data
#+end_src

每次操作后，Taskwarrior 会在 =~/.task/undo.data= 中记录快照。

*** =calc= 命令: 日期计算器

#+begin_src sh
# 计算 "下周五" 是哪一天
task calc friday

# 计算 "30 天后"
task calc now+30d

# 计算 "本月底"
task calc eom
#+end_src

这对于理解 Taskwarrior 的日期解析非常有用。

* Modifications: 字段修改的语法

Modifications 部分指定了对选中任务的 *字段修改*。

** 基本语法: =field:value=

#+begin_src sh
task 12 modify due:tomorrow priority:H project:kernel
#+end_src

规则:

- 多个修改按顺序执行
- 如果 value 为空，则清空字段: =field:=

** 标签的添加和移除

#+begin_src sh
# 添加标签
task 12 modify +bug +urgent

# 移除标签
task 12 modify -wontfix

# 组合
task 12 modify +bug -feature
#+end_src

注意: 标签的 =+= / =-= 在 modifications 中表示 "添加/移除"，而在 filter 中表示 "存在/不存在"。

** 描述的修改

#+begin_src sh
# 完全替换 description
task 12 modify "New description"

# 追加到末尾
task 12 append "additional info"

# 前置到开头
task 12 prepend "URGENT: "
#+end_src

** 正则替换

Taskwarrior 支持类似 =sed= 的替换语法:

#+begin_src sh
# 替换第一个匹配
task 12 modify /old/new/

# 替换所有匹配
task 12 modify /old/new/g

# 大小写不敏感
task 12 modify /OLD/new/gi
#+end_src

示例:

#+begin_src sh
# 批量修正拼写错误
task project:kernel modify /memroy/memory/g
#+end_src

** 日期和时间

Taskwarrior 支持非常灵活的日期语法:

| 语法      | 含义                     |
|-----------+--------------------------|
| =today=     | 今天                     |
| =tomorrow=  | 明天                     |
| =yesterday= | 昨天                     |
| =friday=    | 本周五 (或下周五)           |
| =eom=       | End of month (月末)      |
| =eoy=       | End of year (年末)       |
| =now=       | 当前时刻                  |
| =sow=       | Start of week (周一)     |
| =socm=      | Start of current month   |
| =socq=      | Start of current quarter |
| =socy=      | Start of current year    |
| =later=     | 某个未来时间 (模糊)         |
| =someday=   | 某天 (模糊)               |

*相对日期*:

#+begin_src sh
task 12 modify due:now+3d      # 3 天后
task 12 modify due:eom-7d      # 月末前 7 天
task 12 modify due:now+2w      # 2 周后
task 12 modify due:now+1mo     # 1 个月后
task 12 modify due:now+1y      # 1 年后
#+end_src

*绝对日期*:

#+begin_src sh
task 12 modify due:2025-12-31
task 12 modify due:2025-12-31T14:30:00
#+end_src

** 依赖关系

#+begin_src sh
# 任务 12 依赖于任务 5
task 12 modify depends:5

# 添加多个依赖
task 12 modify depends:5,8,10

# 移除依赖
task 12 modify depends:
#+end_src

查看依赖关系:

#+begin_src sh
task 12 info
task +BLOCKED list     # 被阻塞的任务
task +BLOCKING list    # 阻塞其他任务的任务
#+end_src

** 循环任务

#+begin_src sh
# 每天重复
task add "Daily standup" due:9am recur:daily

# 每周重复
task add "Weekly review" due:friday recur:weekly

# 每月重复
task add "Pay rent" due:28th recur:monthly

# 有限次数重复 (1 年)
task add "Quarterly report" due:eom recur:quarterly until:now+1y
#+end_src

循环任务会自动生成 "子任务" (child tasks)，父任务 (parent) 不会显示在普通报告中。

** 等待时间 (wait)

Wait 字段可以让任务 "延迟出现":

#+begin_src sh
# 任务在 3 天后才出现在 next report 中
task 12 modify wait:now+3d

# 查看等待中的任务
task +WAITING list
#+end_src

这对于 "未来某时再处理" 的任务非常有用。

** 过期时间 (until)

Until 字段让任务在某个时间后 *自动删除*:

#+begin_src sh
# 任务在 2025-12-31 后自动删除
task 12 modify until:2025-12-31
#+end_src

这对于临时任务 (如 "购买圣诞礼物") 很有用。

* Urgency: 自动优先级排序的核心

Urgency (紧迫性) 是 Taskwarrior 最强大的特性之一，也是 =next= report 排序的核心。

** Urgency 的本质: 多项式计算

Urgency 是一个 *实数*，由多个因子的加权和计算而来:

#+begin_example
urgency = Σ (coefficient_i × indicator_i)
#+end_example

每个因子对应一个任务的属性 (如 priority, due date, tags)，每个因子有一个 *系数* (coefficient)，决定了该因子的重要性。

** 默认的 Urgency 系数

Taskwarrior 的默认系数 (2.6.x 版本):

| 因子                   | 系数 | 含义                    |
|------------------------+------+-------------------------|
| =+next= tag              | 15.0 | 特殊标签，极大提升 urgency |
| =due= date               | 12.0 | 有 due date             |
| =blocking= other tasks   |  8.0 | 阻塞其他任务              |
| =priority.H=             |  6.0 | 高优先级                 |
| =scheduled= date         |  5.0 | 已计划                   |
| =active= (started)       |  4.0 | 正在进行中                |
| =priority.M=             |  3.9 | 中优先级                 |
| =age= (任务年龄)          |  2.0 | 年龄越大越紧急 (最多加 2.0) |
| =priority.L=             |  1.8 | 低优先级                 |
| =project=                |  1.0 | 有 project              |
| =tags=                   |  1.0 | 有标签                   |
| =annotations=            |  1.0 | 有 annotation           |
| =waiting=                | -3.0 | 等待中 (降低 urgency)     |
| =blocked= by other tasks | -5.0 | 被阻塞 (降低 urgency)     |

*** 计算示例

假设一个任务:

- =priority:H= → +6.0
- =+bug= tag → +1.0 (有标签)
- =due:tomorrow= → +12.0
- 年龄 30 天 → +0.16 (30/365 × 2.0)
- =project:kernel= → +1.0

总 urgency = 6.0 + 1.0 + 12.0 + 0.16 + 1.0 = *20.16*

*** Due Date 的动态计算

Due date 对 urgency 的贡献不是固定的 12.0，而是根据 *距离截止日期的时间* 动态计算:

#+begin_example
due_contribution = 12.0 × (1 - days_until_due / 14)
#+end_example

- 今天到期: 12.0 × 1 = 12.0
- 7 天后到期: 12.0 × 0.5 = 6.0
- 14 天后到期: 12.0 × 0 = 0
- 已过期: 12.0 × (1 + 超期天数/14)，可能超过 12.0

这让 urgency 能动态反映截止日期的临近程度。

** 查看 Urgency 计算细节

#+begin_src sh
task 12 info
#+end_src

输出中会显示:

#+begin_example
Urgency    20.16
    priority   6    6.0 *  1.0
    tags       1    1.0 *  1.0
    due       12   12.0 *  1.0
    age     0.16    2.0 *  0.08
    project    1    1.0 *  1.0
#+end_example

这让你清楚地看到每个因子的贡献。

** 自定义 Urgency 系数

你可以调整系数来匹配自己的优先级观念:

#+begin_src sh
# 让 +next tag 的影响更大
task config urgency.user.tag.next.coefficient 20.0

# 降低 blocked 任务的惩罚
task config urgency.blocked.coefficient -2.0

# 让某个项目的任务更紧急
task config urgency.user.project.critical.coefficient 5.0

# 自定义标签的系数
task config urgency.user.tag.urgent.coefficient 8.0
task config urgency.user.tag.later.coefficient -6.0
#+end_src

*最佳实践*:

1. 小步调整 (每次 ±1.0)
2. 调整后查看 =next= report，观察排序变化
3. 不要过度拟合，urgency 是一个 *近似*，不是完美算法

** Urgency 的哲学

Urgency 不是你的 "真实优先级"，而是一个 *决策辅助工具*。

正如 Taskwarrior 文档所说:

#+begin_quote
Urgency is just a number, but a number calculated using a polynomial that considers many aspects of your tasks. What this means is that the more information you provide with your tasks, the more accurate the next report becomes, and the more closely it approximates your own notion of urgency.
#+end_quote

关键在于:

1. *提供足够的元数据* (priority, due, project, tags)
2. *定期审查任务列表* (修正过时的 due date, priority)
3. *调整系数* 让 urgency 逼近你的直觉

* 高级技巧

** DOM (Document Object Model): 访问任何数据

Taskwarrior 提供了一个 DOM 系统，允许你访问任务的任意属性:

#+begin_src sh
# 获取任务 12 的 description
task _get 12.description

# 获取创建时间和最后修改时间
task _get 12.entry 12.modified

# 获取 due date 的周数
task _get 12.due.week

# 获取配置项
task _get rc.data.location
#+end_src

这在脚本中非常有用:

#+begin_src bash
#!/bin/bash
for id in $(task +bug status:pending _ids); do
    desc=$(task _get $id.description)
    echo "Bug $id: $desc"
done
#+end_src

** Context: 工作场景切换

Context 是 Taskwarrior 2.5.0+ 的新特性，允许你定义 "工作场景" 并快速切换:

#+begin_src sh
# 定义 context
task context define work project:Work
task context define home 'project:Home or +personal'
task context define urgent '+next or +urgent'

# 激活 context
task context work

# 现在所有命令都自动应用 "project:Work" filter
task list       # 等价于 task project:Work list
task add Fix bug  # 自动加上 project:Work

# 查看当前 context
task context show

# 清除 context
task context none
#+end_src

这避免了重复输入 filter，非常适合 "工作时间只看工作任务，回家只看家庭任务" 的场景。

** UDA (User Defined Attributes): 自定义字段

如果内置字段不够用，可以定义自己的 UDA:

#+begin_src sh
# 定义一个 "size" 字段 (S/M/L/XL)
task config uda.size.type string
task config uda.size.label Size
task config uda.size.values S,M,L,XL,
task config uda.size.default M

# 定义 urgency 系数
task config urgency.uda.size.S.coefficient 1.0
task config urgency.uda.size.M.coefficient 2.0
task config urgency.uda.size.L.coefficient 3.0
task config urgency.uda.size.XL.coefficient 5.0

# 使用
task add "Huge refactoring" size:XL project:kernel
task size:XL list
#+end_src

UDA 可以是:

- =string=: 字符串
- =numeric=: 数字
- =date=: 日期
- =duration=: 时长

** Hooks: 自定义行为

Taskwarrior 支持 *hooks*，在特定事件触发时执行自定义脚本:

| Hook 类型       | 触发时机               |
|---------------+------------------------|
| =on-add=        | 添加任务时             |
| =on-modify=     | 修改任务时             |
| =on-exit=       | 任何命令结束时         |
| =on-launch=     | 任何命令开始时         |

示例: 自动为 =+bug= 任务添加 =priority:H=:

#+begin_src python
#!/usr/bin/env python3
# ~/.task/hooks/on-add-auto-priority

import sys
import json

# 从 stdin 读取新任务
task = json.loads(sys.stdin.readline())

# 如果有 'bug' 标签且没有 priority，设置为 H
if 'bug' in task.get('tags', []) and 'priority' not in task:
    task['priority'] = 'H'

# 输出修改后的任务
print(json.dumps(task))
sys.exit(0)
#+end_src

安装 hook:

#+begin_src sh
chmod +x ~/.task/hooks/on-add-auto-priority
#+end_src

** 与其他工具集成

*** 与 Git 同步任务

#+begin_src sh
# 在 ~/.task/ 目录下初始化 git
cd ~/.task
git init
git add *.data
git commit -m "Initial commit"

# 每次修改后自动提交
task add "Task" && git commit -am "Added task"
#+end_src

*** 与 Timewarrior 集成

Timewarrior 是 Taskwarrior 的姊妹项目，用于时间追踪:

#+begin_src sh
# 启动任务时自动开始计时
task 12 start

# Timewarrior hook 会自动调用
timew

# 停止任务时自动停止计时
task 12 stop
#+end_src

*** 与 org-mode 集成

可以通过 =org-taskwarrior= 包在 Emacs 中管理 Taskwarrior 任务。

** 性能优化

*** GC (Garbage Collection)

Taskwarrior 会保留已删除和已完成的任务，久而久之数据库会膨胀:

#+begin_src sh
# 永久删除已删除的任务
task rc.gc=on list

# 或修改配置
task config gc on
#+end_src

但注意: GC 会 *永久删除* 已删除任务，无法恢复。

*** 限制历史记录

#+begin_src sh
# 限制 completed 任务的保留时间
task config undo.style=side    # 默认值
task config undo.backlog 10    # 只保留最近 10 次操作
#+end_src

* 总结: Taskwarrior CLI 的心智模型

理解 Taskwarrior CLI 的关键在于建立正确的心智模型:

1. *Filter 是查询*: 从任务集合中选出子集 (SQL 的 =WHERE=)
2. *Command 是操作*: 对子集执行操作或生成报告
3. *Modifications 是更新*: 批量修改子集中的任务 (SQL 的 =UPDATE=)
4. *Report 是视图*: 预定义的 filter + 排序 + 列选择
5. *Urgency 是近似*: 多因子加权和，需要调优

*最佳实践*:

1. *少即是多*: 不要过度标记任务，关键信息用 priority/due/project
2. *定期审查*: 用 =tasksh= 的 =review= 命令定期清理过时任务
3. *信任 urgency*: 让 =next= report 指导你的工作，不要过度思考
4. *自定义 report*: 为常见查询创建自定义 report (如 =task today=)
5. *利用 context*: 工作/家庭场景切换，减少认知负担

Taskwarrior 是一个 *工具箱*，不是一个 "方法论"。它不会强迫你使用 GTD 或 Eisenhower Matrix，而是提供灵活的机制让你构建自己的工作流。关键在于找到适合自己的 urgency 系数、report 和 workflow，然后坚持使用。

最后，记住 Taskwarrior 的设计哲学: *低摩擦* (low-friction)。添加任务应该像写便签一样快速，查看任务应该一目了然。如果你发现自己在与 Taskwarrior 搏斗，那可能是配置出了问题，而不是工具的问题。

*开始很简单*:

#+begin_src sh
task add "Learn Taskwarrior"
task add "Read the docs" project:Learning due:tomorrow
task next
task 1 done
#+end_src

这四个命令就是 Taskwarrior 的核心。其余的，都是优化和定制。
