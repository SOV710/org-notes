#+title: The Mythical Man-Month: Why Software Projects Fail and How to Build Better Teams
#+author: SOV710
#+date: 2025-12-22
#+startup: showall
#+options: toc:2 num:nil

* 从程序到编程系统产品: 9 倍成本的真相

一个程序员写出来的程序，和一个真正可以交付给用户、能在生产环境中运行的 *编程系统产品* (Programming System Product) 之间，有着 *天壤之别*。

** 程序 vs. 编程产品 vs. 编程系统 vs. 编程系统产品

Fred Brooks 在《人月神话》中提出了一个经典的 2x2 矩阵:

|            | *单机运行*                       | *系统集成*                                 |
|------------+-------------------------------+-----------------------------------------|
| *个人使用*    | 程序 (Program)                | 编程系统 (Programming System)            |
| *交付他人使用* | 编程产品 (Programming Product) | *编程系统产品* (Programming System Product) |

*** 程序 (Program)

这是最简单的形态: 你在自己的机器上写了一段代码，能跑，能解决你的问题。

- 没有文档 (或者只有几句注释)
- 没有测试 (或者只有手动测试)
- 没有错误处理 (输入不对直接崩溃)
- 只有你自己能用

*成本系数: 1x*

#+begin_src python
# 典型的 "程序"
import sys
data = open(sys.argv[1]).read()
print(sum(int(x) for x in data.split()))
#+end_src

这段代码能用，但:

- 文件不存在? 崩溃
- 内容不是数字? 崩溃
- 别人接手? 看不懂

*** 编程产品 (Programming Product)

这是可以 *交付给他人使用* 的版本，需要:

1. *健壮性*: 处理各种边界情况和错误输入
2. *文档*: 用户手册、API 文档、注释
3. *测试*: 单元测试、集成测试、回归测试
4. *维护性*: 代码结构清晰，易于修改和扩展

*成本系数: 3x*

#+begin_src python
"""
Sum Calculator - 从文件中读取数字并求和

Usage:
    python sum.py <filename>

Requirements:
    - 文件每行一个整数
    - 支持负数和零
"""
import sys
import logging

def sum_file(filename: str) -> int:
    """读取文件并计算整数之和

    Args:
        filename: 输入文件路径

    Returns:
        整数之和

    Raises:
        FileNotFoundError: 文件不存在
        ValueError: 文件内容不是有效整数
    """
    try:
        with open(filename, 'r') as f:
            numbers = [int(line.strip()) for line in f if line.strip()]
        return sum(numbers)
    except FileNotFoundError:
        logging.error(f"文件 {filename} 不存在")
        raise
    except ValueError as e:
        logging.error(f"文件包含无效数字: {e}")
        raise

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python sum.py <filename>")
        sys.exit(1)

    try:
        result = sum_file(sys.argv[1])
        print(f"Sum: {result}")
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)
#+end_src

增加了什么?

- 完整的错误处理
- 类型标注
- Docstring 文档
- 命令行参数检查
- 日志记录

代码量增加了约 3 倍，但这还只是 "编程产品"。

*** 编程系统 (Programming System)

这是一个 *可以与其他系统集成* 的程序:

- 定义清晰的接口 (API, CLI, 配置文件)
- 可以作为更大系统的一部分
- 符合系统级的约定 (如返回码、信号处理)

*成本系数: 3x* (相对于程序)

#+begin_src python
# 编程系统版本: 提供多种接口

# 1. Python API
class SumCalculator:
    def __init__(self, config: dict):
        self.encoding = config.get('encoding', 'utf-8')
        self.ignore_errors = config.get('ignore_errors', False)

    def sum_file(self, filename: str) -> int:
        # ... (实现)
        pass

    def sum_stdin(self) -> int:
        # ... (支持管道输入)
        pass

# 2. CLI 接口
# $ sum-calc --config config.json input.txt
# $ cat input.txt | sum-calc --stdin

# 3. 配置文件
# config.json: {"encoding": "utf-8", "ignore_errors": true}

# 4. 环境变量
# SUM_CALC_ENCODING=gbk sum-calc input.txt

# 5. 返回码
# 0: 成功
# 1: 文件错误
# 2: 格式错误
#+end_src

增加了什么?

- 多种调用方式 (API, CLI, 管道)
- 配置系统
- 环境变量支持
- 标准化的退出码

*** 编程系统产品 (Programming System Product)

这是 *可交付的、可集成的完整产品*，同时满足 "编程产品" 和 "编程系统" 的所有要求:

1. *完整文档*: 用户手册、开发者文档、架构设计文档
2. *全面测试*: 单元测试、集成测试、性能测试、安全测试
3. *维护支持*: Bug 修复、版本管理、兼容性保证
4. *系统集成*: API、CLI、配置、监控、日志
5. *通用化*: 参数可配置、支持多种环境
6. *持续维护*: 依赖更新、安全补丁、性能优化

*成本系数: 9x* (相对于程序)

一个真实的编程系统产品需要:

#+begin_example
项目结构:
sum-calc/
├── src/
│   ├── core.py          # 核心逻辑
│   ├── cli.py           # 命令行接口
│   ├── api.py           # Python API
│   └── config.py        # 配置管理
├── tests/
│   ├── test_core.py     # 单元测试
│   ├── test_cli.py      # CLI 测试
│   ├── test_integration.py  # 集成测试
│   └── test_perf.py     # 性能测试
├── docs/
│   ├── user_guide.md    # 用户手册
│   ├── api_reference.md # API 文档
│   ├── architecture.md  # 架构设计
│   └── changelog.md     # 变更日志
├── examples/            # 使用示例
├── benchmarks/          # 性能基准
├── pyproject.toml       # 项目配置
├── setup.py             # 安装脚本
├── Dockerfile           # 容器化
├── .github/workflows/   # CI/CD
└── README.md
#+end_example

还需要:

- *版本管理*: Semantic Versioning (如 v1.2.3)
- *依赖管理*: =requirements.txt= 或 =poetry.lock=
- *CI/CD*: 自动测试、构建、发布
- *容器化*: Docker 镜像
- *监控*: Prometheus metrics, OpenTelemetry tracing
- *日志*: 结构化日志 (JSON 格式)
- *安全*: CVE 扫描、依赖审计
- *性能*: Profiling, benchmarking
- *兼容性*: 多 Python 版本测试 (3.8, 3.9, 3.10, 3.11, 3.12)
- *国际化*: 多语言支持
- *可访问性*: 错误消息清晰、帮助文档完善

** 为什么是 9 倍?

Brooks 给出的经验数据:

- 程序 → 编程产品: *3 倍成本* (通用化、测试、文档)
- 程序 → 编程系统: *3 倍成本* (接口、集成、兼容性)
- 程序 → 编程系统产品: *3 × 3 = 9 倍成本*

这个数字在现代软件工程中 *依然成立*，甚至更高:

- Google 内部研究: 生产级代码的 *维护成本* 是初始开发成本的 *10-100 倍*
- 微软数据: 每 1 行生产代码需要 3-5 行测试代码
- Linux 内核: 约 3000 万行代码，但有 *数十万* 行测试代码和文档

** 现代案例: SQLite

SQLite 是一个极端的例子:

- *核心代码*: 约 15 万行 C 代码
- *测试代码*: 约 *9180 万行* 测试代码 (test-to-code ratio: *612:1*)
- *文档*: 完整的 SQL 参考手册、C API 文档、设计文档
- *持续维护*: 自 2000 年至今，每年数百个 commit

这就是 "编程系统产品" 的真实成本。

* 乐观主义的陷阱: 为什么所有项目都会延期

** 第一个假设: 一切都将运作良好

系统编程的 *第一个致命假设* 是:

#+begin_quote
*一切都将运作良好，每一项任务仅花费它所 "应该" 花费的时间。*
#+end_quote

这是 *完全错误* 的。

*** Bug 是不可避免的

Brooks 引用了一个统计数据 (1960 年代):

- 每 1000 行代码有 *10-50 个 bug*
- 即使经过测试，交付时仍有 *1-10 个残留 bug*

现代数据 (2020 年代):

- Microsoft: 每 1000 行代码平均 *10-20 个 bug*
- NASA: 航天级软件，每 1000 行代码仍有 *0.1 个 bug* (已经是极低水平)
- Linux 内核: 每年修复 *3000+ 个 bug* (来自 CVE 数据库)

*结论*: 即使最优秀的程序员，也无法写出无 bug 的代码。

*** 为什么程序员总是乐观?

Brooks 给出了一个深刻的心理学解释:

#+begin_quote
"程序员是天生的乐观主义者。如果不是，他们不会编程。"
#+end_quote

原因:

1. *选择性记忆*: 我们记得 "代码一次通过" 的愉悦，忘记 "调试 3 小时" 的痛苦
2. *高估自己*: "这次不一样，我已经有经验了"
3. *低估复杂性*: "就是几个函数调用，能有多难?"

*** 现实: 90/90 法则

Tom Cargill (Bell Labs) 提出的 *90/90 法则*:

#+begin_quote
*前 90% 的代码用掉了 90% 的时间。*
*剩下的 10% 代码又用掉了另外 90% 的时间。*
#+end_quote

用现代术语解释:

- 前 90%: 实现核心功能 (Happy Path)
- 后 10%: 错误处理、边界情况、性能优化、文档、测试

实际项目中:

#+begin_example
预期: "这个功能 2 周完成"
实际:
  - Week 1-2: 核心功能开发 ✓
  - Week 3: 发现边界情况 bug
  - Week 4: 性能不达标，重构
  - Week 5: 用户反馈 UI 不友好
  - Week 6: 补充文档和测试
  - Week 7: 修复回归 bug
  - Week 8: 终于上线 (4 倍时间)
#+end_example

* 人月神话: 为什么加人不能加速项目

** 第二个谬误: 人和月可以互换

#+begin_quote
*人月 (Man-Month) 是一个危险的、具有欺骗性的计量单位。*
#+end_quote

管理者的典型思维:

- "这个项目需要 12 人月"
- "1 个人做 12 个月 = 12 人做 1 个月"
- "所以我投入 12 个人，1 个月就能完成！"

*这是完全错误的。*

** 错误假设 1: 人员之间不需要交流

*** 通信成本是 $O(n^2)$ 的

如果一个团队有 $n$ 个人，通信路径数量是:

$$\text{通信路径} = \frac{n(n-1)}{2}$$

| 人数 | 通信路径 | 增长率       |
|----+--------+------------|
|  2 |      1 | -          |
|  4 |      6 | *6x*         |
|  8 |     28 | *28x*        |
| 16 |    120 | *120x*       |
| 32 |    496 | *496x*       |

当团队从 2 人增加到 32 人，通信复杂度增加了 *496 倍*！

*** 通信成本的具体形式

1. *会议*: 站会、评审、设计讨论
2. *代码审查*: Pull Request review
3. *同步状态*: "你那边进展如何?"
4. *冲突解决*: Merge conflict, 接口不一致
5. *知识传递*: 新人 onboarding

实际案例:

#+begin_example
2 人团队:
  - 每天 15 分钟站会
  - 总通信成本: 30 分钟/天

16 人团队:
  - 站会 1 小时 (每个人汇报)
  - 分组讨论 2 小时
  - 代码审查 2 小时
  - 冲突解决 1 小时
  - 总通信成本: 6 小时/天 × 16 人 = 96 人小时/天

效率损失: (96 - 0.5) / (16 × 8) ≈ 75% 的时间在通信！
#+end_example

*** Brook's Law

#+begin_quote
*向进度落后的项目中增加人手，只会使进度更加落后。*
#+end_quote

原因:

1. *培训成本*: 新人需要 1-3 个月才能上手
2. *干扰老人*: 老员工要花时间指导新人
3. *增加混乱*: 更多的通信路径、更多的冲突

数学模型:

设项目剩余工作量为 $W$，当前有 $n$ 人，新增 $k$ 人:

- 培训成本: $k \times t_{\text{train}}$ (其中 $t_{\text{train}}$ 通常是 1-3 个月)
- 老人指导成本: $n \times k \times t_{\text{mentor}}$ (每个老人要指导每个新人)
- 新人生产力: $k \times p_{\text{new}}$ (其中 $p_{\text{new}} \approx 0.3$ 前期)

总时间增加:

$$\Delta T = \frac{k \times t_{\text{train}} + n \times k \times t_{\text{mentor}}}{n + k \times p_{\text{new}}} > 0$$

*结论*: 项目晚期加人，几乎总是 *净负收益*。

** 错误假设 2: 工作可以完全并行

*** 顺序依赖性

某些任务 *必须串行*:

1. *设计 → 实现 → 测试*: 不能同时进行
2. *前端 → 后端*: 接口未定义前，前端无法开发
3. *数据迁移 → 功能开发*: 数据结构未确定，代码无法写

Brooks 的经典比喻:

#+begin_quote
*一个孕妇需要 9 个月生孩子。*
*9 个孕妇不能在 1 个月内生出孩子。*
#+end_quote

*** 实际项目中的串行部分

Amdahl's Law (阿姆达尔定律) 告诉我们:

设任务中可并行部分占比为 $P$，串行部分为 $(1-P)$，投入 $N$ 个人:

$$\text{加速比} = \frac{1}{(1-P) + \frac{P}{N}}$$

例子:

- 如果任务中 *50% 是串行的* (如设计、集成测试)，投入 100 人，加速比最多只有 *2 倍*
- 如果任务中 *90% 是串行的*，投入 100 人，加速比最多只有 *1.1 倍*

*** 实际案例: OS/360

Brooks 在 IBM 领导 OS/360 项目时:

- 预期: 25 人年 (例如 25 人做 1 年)
- 实际: *5000 人年* (最高峰 1000+ 人同时工作)
- 延期: *2 年*

教训:

- 大量时间花在通信和协调上
- 系统过度复杂，接口混乱
- 晚期加人导致更多混乱

* 小团队 vs. 大团队: 如何破局

** 困境

- *小团队* (2-5 人): 效率高，但无法完成巨大项目
- *大团队* (50+ 人): 能完成大项目，但效率低、通信成本爆炸

如何解决?

** 解决方案: 外科手术式团队 (Surgical Team)

Brooks 提出的革命性方案: *不是把所有人平等对待，而是建立专业化分工*。

*** 传统团队 vs. 外科手术式团队

*传统团队 (民主式)*:

- 所有人平等参与设计、编码、测试
- 每个人都要沟通
- 通信路径: $O(n^2)$

*外科手术式团队 (层级式)*:

- 1 个 *首席程序员* (Chief Programmer): 做核心设计和关键代码
- 1 个 *副程序员* (Co-pilot): 审查代码、备份
- 其他人 *支持* 首席程序员，不参与核心决策

类比手术室:

| 角色            | 职责                  | 人数 |
|---------------+---------------------+----|
| 主刀医生        | 核心操作              |  1 |
| 副刀医生        | 协助、备份            |  1 |
| 麻醉师          | 专职任务 (性能优化)    |  1 |
| 护士            | 工具、仪器 (工具链)    | 2-3 |
| 助理            | 琐碎任务 (测试、文档)  | 2-3 |

*** 角色分工

1. *首席程序员 (Chief Programmer)*
   - 职责: 架构设计、核心算法、关键模块
   - 技能: *顶尖* 程序员 (前 1-5%)
   - 工作量: 占团队代码的 40-60%

2. *副程序员 (Co-pilot)*
   - 职责: 代码审查、提供第二视角、备份
   - 技能: 接近首席程序员水平
   - 不直接写核心代码，但随时可接手

3. *管理员 (Administrator)*
   - 职责: 预算、人事、会议安排
   - 解放首席程序员的时间

4. *编辑 (Editor)*
   - 职责: 文档撰写、格式化、发布
   - 确保文档质量

5. *秘书 (Secretary)*
   - 职责: 协调会议、记录决策、管理文件

6. *程序职员 (Program Clerk)*
   - 职责: 维护代码库、版本管理、构建脚本
   - 现代等价物: DevOps 工程师

7. *工具工程师 (Toolsmith)*
   - 职责: 开发内部工具、脚本、自动化
   - 提升团队生产力

8. *测试工程师 (Tester)*
   - 职责: 设计测试用例、执行测试、报告 bug
   - 不写核心代码

9. *语言律师 (Language Lawyer)*
   - 职责: 解答语言细节、性能优化、编译器特性
   - 现代等价物: 性能工程师、编译器专家

*** 关键原则

1. *单一决策者*: 首席程序员拥有 *最终决策权*
2. *专业化分工*: 每个人只做自己擅长的事
3. *减少通信*: 非核心成员 *不需要* 与所有人沟通

通信路径:

- 传统 10 人团队: $\frac{10 \times 9}{2} = 45$ 条路径
- 外科手术式团队: *约 10 条路径* (所有人只与首席程序员沟通)

*** 现代实践

外科手术式团队在现代的变体:

*Google 的 Tech Lead (TL) 模式*:

- 1 个 TL (Tech Lead): 类似首席程序员
- 2-5 个 SWE (Software Engineer): 实现具体功能
- 1 个 TPM (Technical Program Manager): 管理进度
- 1 个 SRE (Site Reliability Engineer): 运维、监控

*开源项目的 Benevolent Dictator*:

- Linux: Linus Torvalds (首席程序员)
- Python: Guido van Rossum (退休前)
- Rust: 核心团队 (3-5 人)

** 多团队协作: Conway's Law

当项目大到需要 *多个外科手术式团队* 时，如何协调?

*** Conway's Law

#+begin_quote
*组织架构决定系统架构。*

"Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations."
#+end_quote

例子:

- 如果公司有 *前端团队* 和 *后端团队*，系统会自然分为 *前后端分离*
- 如果公司按 *业务线* 划分 (用户、支付、物流)，系统会是 *微服务架构*

*** 逆向应用: 按目标架构组织团队

*目标*: 微服务架构，每个服务独立

*团队结构*:

- 每个服务一个外科手术式团队 (5-10 人)
- 团队 *全栈*: 前端、后端、数据库、运维
- 团队 *独立*: 自主决策、独立发布

*通信*:

- 团队 *内部*: 高频沟通
- 团队 *之间*: 通过 API 合约，低频沟通

*** Amazon 的 Two-Pizza Team

Jeff Bezos 的规则:

#+begin_quote
*一个团队的大小，应该能用两张披萨喂饱。*
(大约 5-10 人)
#+end_quote

好处:

- 通信成本可控
- 决策快速
- 责任明确

* 现代反思: 人月神话在 2025 年还成立吗?

** 技术进步

*** 1. 更好的工具

- *IDE*: 自动补全、重构、静态分析 (VS Code, JetBrains)
- *版本控制*: Git 分布式协作
- *CI/CD*: 自动测试、构建、部署
- *容器化*: Docker, Kubernetes
- *AI 辅助*: GitHub Copilot, ChatGPT

这些工具 *降低了通信成本*，但没有消除。

*** 2. 更好的方法论

- *敏捷开发*: 短迭代、快速反馈
- *微服务*: 团队解耦
- *DevOps*: 开发和运维融合

但 *核心原理不变*:

- 通信成本仍是 $O(n^2)$
- 串行任务仍无法并行
- 大团队仍需要强力协调

** 不变的真理

*** 1. Brooks' Law 依然成立

2023 年 Stack Overflow 调查:

- 70% 的开发者认为 "团队规模增加会降低生产力"
- 最高效的团队规模: *5-9 人*

案例:

- *WhatsApp*: 被 Facebook 以 190 亿美元收购时，只有 *32 名工程师*
- *Instagram*: 被 Facebook 以 10 亿美元收购时，只有 *13 名工程师*
- *SQLite*: 被数十亿设备使用，核心开发者 *2 人*

*** 2. 小团队依然更高效

Jeff Bezos 的 API Mandate (2002):

#+begin_quote
*所有团队必须通过服务接口沟通，任何团队间的数据、功能交互都必须通过服务调用。*

*不允许直接链接、不允许直接读取其他团队的数据、不允许共享内存、不允许任何形式的后门。唯一允许的通信方式是网络调用。*
#+end_quote

结果: Amazon 成功转型为微服务架构，每个小团队独立迭代。

*** 3. 专业化分工是关键

现代团队的角色:

| 角色     | 现代名称                   | 职责         |
|----------+---------------------------+--------------|
| 首席程序员 | Tech Lead, Staff Engineer | 架构、核心代码  |
| 副程序员  | Senior Engineer           | 审查、备份     |
| 工具工程师 | DevOps Engineer           | CI/CD, 工具链 |
| 测试工程师 | QA Engineer, SDET         | 测试、自动化   |
| 编辑     | Technical Writer          | 文档         |
| 管理员    | Engineering Manager       | 人事、预算     |
| 程序职员  | Build Engineer            | 构建、发布     |

*结论*: 人月神话的核心洞察 *在 2025 年依然正确*。技术进步只是 *延缓* 了问题，而非解决。

* 实战建议: 如何组建高效团队

** 1. 保持团队小而精干

*目标*: 5-9 人的核心团队

*原则*:

- 宁缺毋滥: 一个优秀程序员抵得上 10 个平庸程序员
- 避免 "人海战术": 人多不等于力量大

** 2. 明确技术领导

*每个团队必须有一个明确的技术决策者 (Tech Lead)*。

职责:

- 架构设计
- 技术选型
- 代码审查
- 最终决策权

*避免*: "民主投票" 或 "委员会设计" (Design by Committee)。

#+begin_quote
"A camel is a horse designed by committee."
(骆驼是委员会设计的马。)
#+end_quote

** 3. 专业化分工

不要让所有人做所有事。

*好的分工*:

- 1-2 人负责架构和核心代码
- 2-3 人负责功能实现
- 1 人负责测试和质量保证
- 1 人负责工具和自动化

*坏的分工*:

- 所有人都写代码、测试、写文档、开会
- 结果: 所有人都疲于奔命，效率低下

** 4. 减少跨团队依赖

*目标*: 团队之间通过 *清晰的接口* 协作，而非紧密耦合。

*最佳实践*:

- 定义 API 合约 (OpenAPI, gRPC)
- 版本化接口 (Semantic Versioning)
- 契约测试 (Contract Testing)

*避免*:

- 共享数据库
- 直接调用其他团队的内部函数
- 隐式依赖

** 5. 投资工具和自动化

*核心原则*: 让机器做机器的事，让人做人的事。

*值得投资的工具*:

- *CI/CD*: 自动测试、构建、部署 (GitHub Actions, GitLab CI)
- *代码分析*: Linter, formatter, static analyzer (Clippy, ESLint, mypy)
- *监控*: 日志、指标、追踪 (Prometheus, Grafana, Jaeger)
- *文档生成*: API doc, changelog (Swagger, cargo doc)

*ROI*: 投资 1 个人月开发工具，可能节省 10 个人月的手动劳动。

** 6. 警惕晚期加人

*原则*: 项目前期可以加人，*后期禁止加人*。

*时间窗口*:

- *前 30%*: 可以加人 (设计阶段)
- *中 40%*: 谨慎加人 (实现阶段)
- *后 30%*: *禁止加人* (集成、测试、修 bug 阶段)

*后期加人的后果*:

- 老员工被迫指导新人，减慢进度
- 新人不熟悉代码，引入新 bug
- 通信成本激增

** 7. 接受现实

*最重要的一点*: 接受软件工程的本质限制。

#+begin_quote
*没有银弹。*

"There is no single development, in either technology or management technique, which by itself promises even one order of magnitude improvement in productivity, reliability, or simplicity."

(无论是技术还是管理方法，都没有任何单一的进展能够带来 10 倍的生产力、可靠性或简洁性提升。)

— Fred Brooks, "No Silver Bullet" (1986)
#+end_quote

软件工程的 *本质困难* (Essential Difficulties):

1. *复杂性* (Complexity): 软件是人类创造的最复杂的产物
2. *一致性* (Conformity): 必须适应真实世界的混乱
3. *可变性* (Changeability): 需求总是变化
4. *不可见性* (Invisibility): 软件无法可视化

这些是 *本质* 困难，无法通过工具或方法论 *消除*，只能 *缓解*。

* 总结

《人月神话》的核心洞察:

1. *编程系统产品是程序的 9 倍成本*
   - 不要低估 "最后 10%" 的工作量

2. *乐观主义是致命的*
   - Bug 不可避免，永远预留调试时间

3. *人月是危险的计量单位*
   - 人和月不可互换
   - 通信成本是 $O(n^2)$

4. *Brooks' Law*
   - 向进度落后的项目加人，只会更慢

5. *外科手术式团队*
   - 小团队 + 专业化分工
   - 明确的技术领导

6. *Conway's Law*
   - 组织架构决定系统架构
   - 按目标架构组织团队

*最重要的教训*:

#+begin_quote
*软件工程不是制造业，不能靠堆人力解决问题。*

*关键在于: 更好的设计、更小的团队、更清晰的接口、更强的工具。*
#+end_quote

*致敬 Fred Brooks (1931-2022)*​，他在 1975 年写下的这些洞察，在 50 年后依然是软件工程的基石。
