#+title: What Experience Really Means in Computer Science: Beyond Tool Chains and Sunk Costs
#+author: SOV710
#+date: 2025-12-22
#+startup: showall
#+options: toc:2 num:nil

* 引子: 我到底学了什么？

我从开始学 CS 到现在也差不多一年了，从开始到现在的一个疑惑就是: *我学了这么久，到底学了什么？*

这个问题也启发于我对水群和周围遇到的一些老登的观察。有些老登锐评: "程序员之所以有 35 岁危机，就是因为他们在 35 岁的时候没有积累到那个岁数应有的经验。" 但是，对于计算机，或者说对于互联网行业来说，*经验是什么呢？*

相信大家都有过这样的经验，就是发现自己解决某一个问题的经验 *无法迁移*。无论是调通一个特定的 API，还是发现自己的 bug 是由一个很愚蠢的 typo 造成的，还是说是因为依赖不兼容造成的崩溃，这些经验要应用到下次都是相当困难的。有时候感觉学 CS 学了很久，回过头来却发现自己甚至更焦虑了，因为觉得自己学的东西完全构不成护城河。

所以在本文中，我将剖析 CS 真正的 "经验" 是什么，真正构成行业护城河的 "经验" 是什么。

* 第一层: 工具链——最容易贬值的 "经验"

** 工具链的入门陷阱

初学者往往会遇到的第一个问题是 *如何使用工具链*。我还记得我第一次学 C 语言时，做的第一件事是到 Google 上搜 "the best IDE for C language"，最后犹豫良久还是选了 Visual Studio，然后遇到的第二个问题是装 Linux 桌面，然后我不得不把我用了三个月的 VS 换成 CLion，后来又换成了现在的 Neovim。

其实学习互联网的大部分时间本质上也是在 *熟悉各种工具链*，无论是学语言、学框架、学轮子、配环境、配插件、薅 API 羊毛，都可以理解为在学习各种工具来让自己能完成业务需求。

** 工具链的致命问题: 非线性演化

但是工具链更新的逻辑 *不是像 commits 一样递进的*，它更像是一条链直接完全替换了另一条链:

- Git 替换了 SVN / CVS
- =uv= 替代了 Poetry / pyenv
- Docker 替代了虚拟机
- Rust 的 =cargo= 让 C/C++ 的 Makefile/CMake 显得古老
- LSP (Language Server Protocol) 让传统 IDE 插件体系过时
- Wayland 正在替代 X11

你投入在前一条工具链上的时间 *完全是沉没成本*。

** 工具链经验的半衰期

我观察到的工具链经验半衰期 (从学习到失效):

| 工具类型              | 半衰期     | 典型例子                          |
|---------------------|-----------|----------------------------------|
| 编辑器 / IDE         | 5-10 年   | Vim → Neovim, Emacs → Doom Emacs |
| 构建工具             | 2-5 年    | Make → CMake → Meson → xmake     |
| 包管理器             | 3-7 年    | pip → pipenv → poetry → uv       |
| 前端框架             | 1-3 年    | jQuery → Angular → React → Vue → Svelte |
| 部署工具             | 3-5 年    | 裸金属 → VM → Docker → K8s → Serverless |
| 版本控制             | 10+ 年    | SVN → Git (Git 已统治 15+ 年)     |

注意前端框架的半衰期只有 *1-3 年*，这意味着你花 6 个月精通 Angular，两年后这个技能就贬值了。

** 工具链只是门槛，不是护城河

所以说，工具链虽然构成了新手入门的第一道门槛，但是 *只能算作最浅层的经验*:

- *必要但不充分*: 你必须会用工具，但光会用工具不够
- *容易习得*: 大部分工具学习曲线在几周到几个月
- *容易过时*: 平均 3-5 年就要重新学一套
- *难以迁移*: Vim 的经验不能帮你学 VSCode

真正的老手特征不是 "精通 50 种工具"，而是 *能快速上手任何新工具*，因为他们理解了工具背后的 *共通抽象*。

* 第二层: 领域知识——可迁移但有局限的经验

** 什么是领域知识

领域知识 (Domain Knowledge) 是指 *特定技术栈或业务场景下的深度理解*:

- Web 后端: HTTP/REST/GraphQL, 数据库索引, 缓存策略
- 嵌入式: 中断处理, DMA, 功耗优化
- 机器学习: 数据预处理, 超参数调优, 模型压缩
- 游戏开发: 物理引擎, 渲染管线, 网络同步
- 金融系统: 事务一致性, 审计日志, 合规要求

** 领域知识的价值

领域知识比工具链更有价值，因为:

1. *迁移范围更广*: 懂数据库索引的人，换到任何关系型数据库都能快速上手
2. *半衰期更长*: HTTP 协议从 1991 年到现在，核心概念没变
3. *构成竞争力*: 深度的领域知识能让你在特定赛道上碾压新手

*** 实际案例: 数据库索引

假设你在公司 A 用 MySQL，跳槽到公司 B 用 PostgreSQL:

- *工具链经验*: MySQL 的 =SHOW INDEX= 语法 → *无法迁移*
- *领域知识*: B-Tree 索引原理、覆盖索引、索引选择性 → *完全迁移*

你可以在 1 天内学会 PostgreSQL 的语法差异，但 B-Tree 的理解是通用的。

*** 实际案例: 嵌入式开发

假设你在做 STM32 项目，后来转到 LoongArch64:

- *工具链经验*: STM32CubeIDE 的配置界面 → *无法迁移*
- *领域知识*: DMA 工作原理、中断优先级设计、Cache 一致性 → *完全迁移*

ARM 和 LoongArch 的指令集不同，但 DMA 的本质 (绕过 CPU 直接搬运内存) 是一样的。

** 领域知识的局限

但领域知识仍然有局限:

1. *跨领域不迁移*: Web 后端的经验帮不了嵌入式开发
2. *技术栈革命*: 如 Serverless 改变了传统运维的很多假设
3. *业务绑定*: 金融系统的合规经验在游戏行业无用

所以，领域知识是 *中层经验*——比工具链强，但还不够。

* 第三层: 基础原理——真正的护城河

** 什么是基础原理

基础原理是指 *跨领域、跨时代的计算机科学核心概念*:

*** 数据结构与算法

- 哈希表、树、图的特性和应用场景
- 时间/空间复杂度分析
- 动态规划、贪心、分治的本质

这些知识从 1960 年代到现在 *几乎没变*。无论你用 Python 还是 Rust，哈希表的平均 O(1) 查找特性都成立。

*** 操作系统原理

- 进程/线程/协程的本质区别
- 虚拟内存、分页、TLB
- 上下文切换的开销
- 文件系统的 inode 结构

这些知识能解释:

- 为什么 Golang 的 Goroutine 比线程轻量
- 为什么 mmap 比 read/write 快
- 为什么 Wayland 比 X11 少一次拷贝

*** 网络原理

- TCP 三次握手/四次挥手的本质 (可靠性 vs 开销)
- UDP 的适用场景 (实时性 > 可靠性)
- HTTP/2 的多路复用原理
- NAT 穿透的本质

这些知识能让你理解:

- 为什么 QUIC (HTTP/3) 要基于 UDP
- 为什么 P2P 需要打洞
- 为什么 CDN 能加速

*** 编译原理

- 词法分析、语法分析、语义分析
- AST (抽象语法树) 的本质
- 寄存器分配、指令选择
- JIT vs AOT 的权衡

这些知识能让你理解:

- 为什么 Python 慢、为什么 Rust 快
- 为什么 JavaScript 的 V8 引擎能这么快
- 为什么 LSP 能做到跨编辑器

*** 计算机体系结构

- CPU 缓存层级 (L1/L2/L3)
- Cache Line、False Sharing
- 流水线、分支预测、乱序执行
- NUMA、多核一致性协议 (MESI)

这些知识能让你理解:

- 为什么我的 [[https://claude.ai/chat/f0aef92b-5f80-4fdd-82df-a2ca9e6f8e64][线程间通信笔记]] 中，跨核通信比同核慢 10 倍
- 为什么 =alignas(64)= 能优化性能
- 为什么 SIMD 指令能加速

** 基础原理的核心价值

基础原理是 *最高层的经验*，因为:

1. *永不过时*: 计算机体系结构 50 年没本质变化
2. *全领域适用*: 无论你做 Web/嵌入式/AI，都需要懂操作系统
3. *解释一切*: 能从第一性原理推导出工具链和领域知识
4. *快速学习*: 懂原理的人学新技术只需看 "和已知有何不同"

*** 实际案例: 理解 Rust 的 Ownership

如果你只学过 Python，看到 Rust 的 ownership 会觉得很诡异:

#+begin_src rust
let s1 = String::from("hello");
let s2 = s1;  // s1 被 move，不能再用
// println!("{}", s1);  // 编译错误
#+end_src

但如果你懂 *操作系统的内存管理*:

- 堆内存需要手动释放 (C 的 =malloc/free=)
- GC 语言 (Python/Java) 用垃圾回收器，有运行时开销
- Rust 用 *编译期的所有权检查* 来保证内存安全，零运行时开销

理解这个原理后，Rust 的很多 "奇怪" 设计就豁然开朗了:

- =Box<T>= 是堆分配
- =&T= 是借用 (类似 C 的指针，但编译器保证不悬垂)
- =Arc<T>= 是引用计数 (类似 C++ 的 =shared_ptr=)

*** 实际案例: 理解 React 的虚拟 DOM

如果你只学过 jQuery，看到 React 会觉得多此一举: "为什么不直接操作 DOM？"

但如果你懂 *操作系统的系统调用开销*:

- DOM 操作是昂贵的 (涉及浏览器渲染引擎的重排/重绘)
- 频繁操作 DOM = 频繁的 "系统调用" (从 JS 引擎到渲染引擎)

React 的虚拟 DOM 是 *批处理* 的思想:

1. 在内存中构建轻量级的 JS 对象树 (Virtual DOM)
2. Diff 算法找出最小变更
3. 一次性批量更新真实 DOM

这和操作系统的 *页缓存* (Page Cache) 思想一模一样: 先在内存中操作，最后一次性刷盘。

*** 实际案例: 理解为什么 HTTP/3 用 UDP

如果你只学过 HTTP/1.1，可能觉得 "TCP 很好啊，为什么要换 UDP？"

但如果你懂 *网络原理*:

- TCP 的 *队头阻塞* (Head-of-Line Blocking): 一个包丢失会阻塞整个连接
- TCP 的状态在 *内核*，用户态无法优化
- UDP 是无连接的，可以在 *用户态* 实现自定义协议

HTTP/3 的 QUIC 协议:

- 基于 UDP (绕过内核 TCP 栈)
- 在用户态实现可靠传输 (类似自己写了个 TCP)
- 多路复用在 *流* (stream) 级别，而非连接级别

这是 *端到端原则* (End-to-End Principle) 的经典应用: 把复杂度上推到应用层，保持网络层简单。

** 如何积累基础原理

*** 1. 读经典教材

| 领域         | 经典教材                                      | 备注                    |
|------------|-------------------------------------------|------------------------|
| 数据结构与算法  | *CLRS* (算法导论)                            | 圣经级，但偏理论            |
|            | *算法* (Sedgewick)                         | 更工程化，有大量代码          |
| 操作系统      | *OSTEP* (Operating Systems: Three Easy Pieces) | 免费在线，写得通俗           |
|            | *CSAPP* (深入理解计算机系统)                    | 必读，从硬件到软件全覆盖        |
| 网络         | *Computer Networking: A Top-Down Approach* | 自顶向下，适合入门           |
|            | *TCP/IP 详解 卷 1*                         | 深入协议细节              |
| 编译原理      | *龙书* (Compilers: Principles, Techniques, and Tools) | 经典但难啃               |
|            | *Crafting Interpreters*                    | 免费在线，实战导向           |
| 体系结构      | *CSAPP* 第 4-6 章                          | 覆盖缓存、流水线、并发        |
|            | *Computer Organization and Design* (Patterson & Hennessy) | RISC-V 版最新           |

*** 2. 实践中验证

*纸上得来终觉浅，绝知此事要躬行。*

- 学了缓存原理？写个 [[https://github.com/torvalds/linux/blob/master/tools/perf/bench/mem-memcpy.c][microbenchmark]] 测量 L1/L2/L3 的延迟
- 学了 TCP 三次握手？用 =tcpdump= 抓包亲眼看到 SYN/SYN-ACK/ACK
- 学了虚拟内存？写个程序故意触发 Page Fault，用 =perf= 统计次数
- 学了编译原理？用 LLVM 写个简单的 DSL 编译器

*** 3. 阅读优秀的源码

| 项目            | 学习重点                        | 代码量 (LOC) |
|---------------|-----------------------------|-----------:|
| Redis         | 数据结构实现、事件驱动、持久化策略           |     ~30K   |
| SQLite        | B-Tree 实现、事务 ACID、查询优化       |    ~150K   |
| Nginx         | 事件驱动架构、零拷贝、内存池              |    ~100K   |
| Linux Kernel  | 进程调度、内存管理、文件系统 (太大，选择性阅读)   |  ~30M (!) |
| Git           | Merkle Tree、内容寻址、Delta 压缩   |    ~300K   |
| Tokio (Rust)  | 异步运行时、Future、调度器            |     ~50K   |

推荐从 *Redis* 开始，代码量小 (~30K 行)，但包含了数据结构、网络、持久化的精髓。

*** 4. 写博客和技术文档

*费曼学习法*: 能讲清楚才是真懂。

- 写博客逼你 *系统化* 知识 (不能只懂一半)
- 写文档逼你 *抽象化* 知识 (不能依赖具体案例)
- 回答问题逼你 *迁移化* 知识 (用不同角度解释)

我自己写的 [[https://claude.ai/chat/f0aef92b-5f80-4fdd-82df-a2ca9e6f8e64][线程间通信笔记]] 和 [[https://claude.ai/chat/5c29f22d-a73f-4c1b-89f9-c7c44a9f0d8b][EDID 笔记]]，就是在倒逼自己把碎片化的经验 *结构化*。

* 第四层: 元认知——学习如何学习

** 什么是元认知

元认知 (Metacognition) 是 *对认知过程的认知*，即:

- 知道自己 *知道什么、不知道什么* (自我评估)
- 知道 *如何高效学习新知识* (学习策略)
- 知道 *如何调试自己的思维* (思维纠错)

这是 *最高层的经验*，因为它能 *加速所有其他层的积累*。

** 元认知的核心能力

*** 1. 快速建立心智模型

*心智模型* (Mental Model) 是你对某个系统的 *简化理解*。

*例子: 理解 Git*

初学者的心智模型 (错误):

#+begin_quote
Git 是一个 "版本管理工具"，像 Google Docs 的版本历史一样。
#+end_quote

进阶者的心智模型 (正确):

#+begin_quote
Git 是一个 *内容寻址的文件系统*，每个 commit 是一个 Merkle Tree 节点。分支是指向 commit 的指针，merge 是合并两个 DAG 路径。
#+end_quote

有了正确的心智模型，很多操作就能 *推导* 出来:

- =git reset --hard= 是移动 HEAD 指针
- =git rebase= 是重新应用一系列 patch
- =git cherry-pick= 是复制一个 commit 到当前分支

*** 2. 识别知识的层次

*好的学习者会问*: "这个知识属于哪一层？"

| 问题                        | 答案所在层次  | 重要性 |
|---------------------------|-----------|------|
| "VSCode 的快捷键是什么？"       | 工具链       | 低    |
| "LSP 的工作原理是什么？"        | 领域知识      | 中    |
| "为什么 LSP 能跨编辑器？"       | 基础原理      | 高    |
| "如何设计一个可扩展的插件系统？"  | 元认知       | 最高  |

*坏的学习路径*: 花 80% 时间在工具链，20% 在基础原理。
*好的学习路径*: 花 20% 时间在工具链 (够用就行)，80% 在基础原理。

*** 3. 善用类比和迁移

*类比* 是把新知识映射到已知领域。

*例子: 理解 Kubernetes*

如果你懂操作系统:

| OS 概念          | K8s 对应概念       | 类比                          |
|----------------|-----------------|------------------------------|
| 进程             | Pod             | 运行单元                        |
| 调度器           | Scheduler       | 决定 Pod 在哪个节点运行              |
| 内存管理          | Resource Quota  | 限制 Pod 的 CPU/内存              |
| 文件系统          | Volume          | 持久化存储                       |
| 进程间通信 (IPC)   | Service         | Pod 之间的网络通信                 |
| cgroup          | Namespace       | 隔离和资源限制                     |

类比的好处:

- *降低认知负担*: 不需要从零理解 K8s
- *快速定位差异*: 只需学 "K8s 和 OS 哪里不同"
- *举一反三*: 懂 K8s 后再学 Docker Swarm 就很快

*** 4. 主动寻找反馈循环

*反馈循环* 是 *行动 → 结果 → 调整* 的过程。

*坏的学习*: 看完一本书 → 没写代码 → 不知道自己懂不懂
*好的学习*: 看一章 → 写代码验证 → 遇到 bug → 理解更深 → 继续下一章

*** 实际案例: 我学 Rust 的过程

| 阶段   | 行动                        | 反馈                          | 调整                          |
|------|---------------------------|------------------------------|------------------------------|
| Week 1 | 读 *The Rust Book* 前 5 章   | 概念懂了，但不知道怎么写              | 找了个小项目 (CLI 工具) 练手         |
| Week 2 | 写 CLI 工具，遇到 borrow checker 报错 | 理解了 "可变借用不能共存" 的原因        | 重新读 Chapter 4 (Ownership)    |
| Week 3 | 实现了 JSON 解析器             | 理解了 =Result<T, E>= 的错误处理模式  | 学习了 =?= 操作符和 =thiserror= 库   |
| Week 4 | 写了个多线程爬虫               | 理解了 =Arc<Mutex<T>>= 的必要性     | 学习了 =tokio= 异步运行时           |

每周都有 *快速反馈*，而不是看完整本书再写代码。

** 元认知的实践方法

*** 1. 费曼学习法

#+begin_quote
*费曼学习法*: 如果你不能用简单的语言解释一个概念，说明你还没真正理解它。
#+end_quote

步骤:

1. 选一个概念 (如 "虚拟内存")
2. 用最简单的语言解释给一个 *完全不懂* 的人 (如你的非 CS 朋友)
3. 遇到卡壳的地方，说明你理解不深
4. 重新学习那部分，再解释一遍

我的 [[https://claude.ai/chat/5c29f22d-a73f-4c1b-89f9-c7c44a9f0d8b][EDID 笔记]] 就是在践行费曼法: 我能用最通俗的语言解释 "显示器和电脑如何握手"，说明我真懂了。

*** 2. 刻意练习

#+begin_quote
*刻意练习* (Deliberate Practice): 不是重复做你已经会的事，而是 *持续挑战你的舒适区边界*。
#+end_quote

*坏的练习*: 刷 100 道简单的 LeetCode Easy 题
*好的练习*: 刷 20 道你 *刚好做不出来* 的 Medium/Hard 题

*坏的练习*: 用熟悉的 Python 写第 10 个 CRUD 应用
*好的练习*: 用 Rust 写一个你 *从未做过* 的系统 (如内存分配器)

*** 3. 构建知识图谱

用 Org-mode / Obsidian / Notion 构建 *个人知识库*:

#+begin_example
CS 基础原理/
├── 操作系统/
│   ├── 进程与线程.org
│   ├── 虚拟内存.org
│   └── 文件系统.org
├── 网络/
│   ├── TCP 三次握手.org
│   ├── HTTP 演化史.org
│   └── 拥塞控制.org
├── 数据结构/
│   ├── 哈希表.org
│   ├── B-Tree.org
│   └── LSM-Tree.org
└── 体系结构/
    ├── 缓存一致性.org
    ├── 分支预测.org
    └── SIMD.org
#+end_example

*关键*: 不是简单地复制粘贴，而是 *用自己的语言重新组织*。

*** 4. 定期复盘

每周/每月问自己:

1. 这周学了什么 *新概念*？(工具链/领域知识/基础原理)
2. 这周解决的问题中，哪些经验可以 *迁移*？
3. 这周遇到的困难，*根本原因* 是什么？(缺基础原理？缺实践？)
4. 下周的学习目标是什么？(填补哪块短板？)

* 总结: 经验的金字塔

#+begin_example
        元认知 (学习如何学习)
       /                      \
      基础原理 (永不过时)
     /                          \
    领域知识 (可迁移，有局限)
   /                              \
  工具链 (易学易忘，必要但不充分)
#+end_example

** 35 岁危机的本质

*真相*: 35 岁危机的人，往往是把 *10 年时间全花在了工具链和浅层领域知识*，没有积累基础原理和元认知。

他们的 "10 年经验" 实际上是 *1 年经验重复 10 次*:

- 用 React 写了 10 年 CRUD，但不懂虚拟 DOM 的本质
- 调了 10 年 Bug，但不懂如何系统性地 Debug
- 用了 10 年 MySQL，但不懂 B-Tree 和 MVCC

而真正的 "10 年经验" 应该是:

- *1-2 年*: 熟悉工具链，能完成业务需求
- *3-5 年*: 深入领域知识，能解决复杂问题
- *5-8 年*: 掌握基础原理，能设计系统架构
- *8-10 年*: 形成元认知，能快速学习任何新领域

** 如何构建真正的护城河

*** 1. 60% 时间学基础原理

- 数据结构、算法、操作系统、网络、体系结构
- 这些知识 *永不过时*，是一切的基石

*** 2. 30% 时间深耕领域

- 选 1-2 个领域深入 (如嵌入式、后端、AI)
- 读论文、读源码、写博客

*** 3. 10% 时间追工具链

- 够用就行，不要沉迷于 "最新最酷的框架"
- 重点理解 *为什么这个工具出现*，而非怎么用

*** 4. 持续输出

- 写博客、做开源、回答问题
- *教是最好的学*

** 一年后的我，应该学会了什么？

如果你现在是 CS 新手，一年后你应该:

- [X] 熟练掌握 *至少一门* 系统级语言 (C/Rust/Go) 和一门脚本语言 (Python/JS)
- [X] 能从 0 搭建一个 *完整的项目* (前后端 + 数据库 + 部署)
- [X] *理解* 操作系统的进程/线程/虚拟内存 (读完 OSTEP 或 CSAPP 的核心章节)
- [X] *理解* 网络的 TCP/IP/HTTP (能用 Wireshark 抓包分析)
- [X] *理解* 常见数据结构的时间复杂度和适用场景
- [ ] 读过 *至少 5000 行* 优秀的开源代码 (Redis/SQLite/Nginx)
- [ ] 写过 *至少 3 篇* 深度技术博客
- [ ] 能 *快速学习* 任何新工具/框架 (1-2 周上手)

不要焦虑 "学了这么多还是什么都不会"，因为 *真正的经验不是工具链的堆砌，而是基础原理的沉淀*​。

*Stay curious. Stay hungry. Keep building.*
