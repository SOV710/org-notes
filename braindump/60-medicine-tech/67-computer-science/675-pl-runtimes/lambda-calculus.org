#+title: The Nature of Computing: λ-calculus
#+author: SOV710
#+date: <2026-02-26 Thu>

* 编程语言的使命

首先, 我们为什么要编程语言?

从数电的布尔代数, 到打纸带再到汇编, 到 c, erlang, lisp, haskell, rust, 他们的最终「使命」是什么?

编程语言是人类意图与机器执行之间的翻译协议

更精确的说:

*编程语言的使命是以「人类」可以「精确」表达的形式, 描述「计算」过程*

- *人类可读性*: 语言需要符合人类的认知结构, 这就是为什么打纸带被完全淘汰了
- *精确*: 排除自然语言的歧义, 这就是为什么我们不能用自然语言编程
- *计算*: 这是所有编程语言的​*本质*, 每个编程语言必须在描述一种计算过程, 否则它就不是编程语言


今天, 我们不谈可读性, 只谈如何数学上「精确地」描述一种「计算过程」

* 什么是计算
直觉上, 计算就是 "按规则变换符号"。你有一些符号, 有一套规则, 然后你不断应用规则, 直到得到结果。

*图灵机*​和 *λ 演算*​两种独立的数学框架都独立捕捉到了这种直觉, 并且给出了两种「计算」的定义框架, 二者被证明完全等价

它们就是「计算」本身, 它们等价不代表它们在「计算能力」上等价, 图灵机的转移表完全可以由 $\lambda$ 演算的一个 $\beta$​-归约来完全表示

证明 $\lambda$ 演算能被图灵机表示有个比理论更直观的方式, 那就是 lisp 和 haskell 已经在图灵机的物理实现 —— 现代计算机 —— 上工作了, 理论推导也简单, $\lambda$ 归约是 $\beta$​-归约: 找到一个 ​$(\lambda x.\, e_1)\; e_2$, 做代换

这个操作完全可以被图灵机机械地执行:
1. 把λ表达式编码为纸带上的字符串（括号+字母）
2. 扫描纸带, 找到最左边的 redex（可归约项）
3. 执行代换：找到 $e_1$ 里所有 $x$ 的出现, 替换为 $e_2$
4. 重复, 直到没有 redex

** Turing Machine

*** Formal Definition

一台图灵机是一个七元组 :

$M = (Q, \Sigma, \Gamma, \delta, q_0, q_{accept}, q_{reject})$

- $Q$ —— 有限状态集
- $\Sigma$ —— 输入字母表 ( 不含空白符 )
- $\Gamma$ —— 纸带字母表, $\Sigma \subset \Gamma$, 含空白符 $\sqcup$
- $\delta: Q \times \Gamma \to Q \times \Gamma \times \{L, R\}$ —— 转移函数
- $q_0 \in Q$ —— 初始状态
- $q_{accept}, q_{reject} \in Q$ —— 接受 / 拒绝状态

**** Configuration

*格局 (Configuration)* 是计算在某一时刻的完整快照 :

$C = uqv \quad u,v \in \Gamma^*, q \in Q$

表示纸带内容为 $uv$, 读写头在 $v$ 的第一个字符处, 当前状态为 $q$。

**** One-Step Transition

*一步转移*​定义为格局之间的关系 $\vdash$ :

$ua\,q\,bv \;\vdash\; uaq'cv \quad \text{if } \delta(q,b) = (q', c, R)$

$uaq\,bv \;\vdash\; u\,q'acv \quad \text{if } \delta(q,b) = (q', c, L)$

**** Computation

*计算*​是格局的序列 :

$C_0 \vdash C_1 \vdash C_2 \vdash \cdots$

当到达 $q_{accept}$ 或 $q_{reject}$ 时终止。

*** Computational Intuition

图灵机捕捉的是 *工人按操作手册工作* 的直觉。

有一条无限长的纸带 (内存), 一个读写头 (程序计数器 + ALU), 一本操作手册 (转移函数)。工人在任意时刻只做一件事: 看当前格子写的什么, 查手册, 改写这格, 往左或往右移一步, 换一个心理状态。

计算的关键特征:

- *局部性*: 每一步只依赖当前状态和当前符号
- *顺序性*: 步骤严格线性推进
- *有状态性*: 结果是全局状态的演变

#+begin_quote
图灵机回答的问题是: 什么问题是机器可以解决的 ?
#+end_quote

这非常接近真实硬件的工作方式 —— 寄存器, 内存, 程序计数器, 本质上就是图灵机的物理实现。

** Lambda Calculus

*** Formal Definition

**** Syntax

项的归纳定义 :

$e ::= x \mid \lambda x.\, e \mid e_1\; e_2$

三条构造, 仅此而已 : 变量, 函数抽象, 函数应用。

**** Free Variables

$FV(x) = \{x\}$

$FV(\lambda x.\, e) = FV(e) \setminus \{x\}$

$FV(e_1\; e_2) = FV(e_1) \cup FV(e_2)$

**** Substitution

*代换* (capture-avoiding substitution) $e_1[x := e_2]$ : 将 $e_1$ 中 $x$ 的自由出现替换为 $e_2$, 必要时做 $\alpha$​-重命名以避免变量捕获。

**** Reduction Rules

1. $\alpha$-conversion : $\lambda x.\, e \;\to_\alpha\; \lambda y.\, e[x := y] \quad (y \notin FV(e))$
2. $\beta$-reduction : $(\lambda x.\, e_1)\; e_2 \;\to_\beta\; e_1[x := e_2]$
3. $\eta$-reduction : $\lambda x.\, (e\; x) \;\to_\eta\; e \quad (x \notin FV(e))$

其中 $\beta$​-reduction 是计算的核心, $\alpha$ 只是重命名, $\eta$ 表达函数的外延相等。

**** Computation

计算是项在 $\to_\beta$ 下的归约序列 :

$e_0 \to_\beta e_1 \to_\beta e_2 \to_\beta \cdots$

当项无法继续 $\beta$​-归约时, 称其为 *$\beta$​-范式 ( $\beta$​-normal form )*, 计算结束。

**** Church-Rosser Theorem

*合流性 ( Confluence )* :

$e \twoheadrightarrow e_1 \text{ and } e \twoheadrightarrow e_2 \implies \exists\, e_3,\; e_1 \twoheadrightarrow e_3 \text{ and } e_2 \twoheadrightarrow e_3$

即无论选择什么归约顺序, 如果最终能到达范式, 范式是唯一的。

*** Church Encoding

一切皆函数。数字与布尔值均可编码为纯 $\lambda$ 项 :

- $\mathbf{0} = \lambda f.\, \lambda x.\, x$
- $\mathbf{1} = \lambda f.\, \lambda x.\, f\; x$
- $\mathbf{true} = \lambda t.\, \lambda f.\, t$
- $\mathbf{false} = \lambda t.\, \lambda f.\, f$

这意味着, 没有比 $\lambda$ 更加底层的公理和定义了, 没有类型了, $\lambda$ 就是最底层的原语

*** Computational Intuition

$\lambda$ 演算捕捉的是 *代入与化简* 的直觉, 就像在数学课上化简表达式一样。

$(\lambda x.\, x + 1)\; 5$ 的意思是"把 5 代入 $x+1$", 结果是 $6$。没有内存, 没有状态, 没有时间顺序 —— 只有表达式, 和表达式之间的等价关系。

计算的关键特征:

- *无状态性*: 程序是数学对象, 不存在可变内存
- *代换即执行*: 函数应用的语义完全由代换定义
- *等价而非过程*: 执行是寻找范式, 而非追踪步骤

#+begin_quote
$\lambda$ 演算回答的问题是: 计算的代数结构是什么 ?
#+end_quote

-----

** Comparison

图灵机的基本操作是 *赋值* (改写纸带), $\lambda$ 演算的基本操作是 *代换* (函数应用)。

以下为两者核心维度的对比 :

- *计算的载体* : 图灵机使用状态 + 纸带 ; $\lambda$ 演算使用表达式
- *一步计算* : 图灵机执行状态转移 ; $\lambda$ 演算执行 $\beta$-归约
- *计算的结果* : 图灵机输出纸带上的内容 ; $\lambda$ 演算输出范式
- *时间观* : 图灵机有显式的步骤序列 ; $\lambda$ 演算的时间隐式于归约关系中
- *内存观* : 图灵机有显式内存 ( 纸带 ) ; $\lambda$ 演算中内存不存在
- *对应范式* : 图灵机对应命令式编程 ; $\lambda$ 演算对应函数式编程

这两个操作之间的张力, 就是命令式编程和函数式编程之间几十年争论的根源。

* Halting Problem

** Formal Definition

图灵机是一个七元组 $H = (Q, \Sigma, \Gamma, \delta, q_0, q_{accept}, q_{reject})$, 其中:

- $Q$ 是有限状态集
- $\Sigma$ 是输入字母表, 满足 $\sqcup \notin \Sigma$
- $\Gamma$ 是纸带字母表, 满足 $\Sigma \subseteq \Gamma$ 且 $\sqcup \in \Gamma$
- $\delta : (Q \setminus \{q_{accept}, q_{reject}\}) \times \Gamma \to Q \times \Gamma \times \{L, R\}$ 是转移函数
- $q_0 \in Q$ 是初始状态
- $q_{accept} \in Q$ 是接受状态
- $q_{reject} \in Q$ 是拒绝状态, 且 $q_{reject} \neq q_{accept}$

*停机问题*​定义为判定以下语言是否可判定:

$HALT = \{ \langle H, w \rangle \mid H \text{ halts on input } w \}$

*定理 (Turing, 1936)*: $HALT$ 是不可判定的, 即不存在图灵机能判定 $HALT$。


** Intuition

停机问题的直觉等价于如下场景: 假设有一个工人, 完全知晓某台机器的转移规则, 也知道该机器即将接受的输入, 让它进行完全机械的逐步推导 — 它能否判断该机器最终会停机？

在某种意义上, 这是可行的。给定 $H$ 和具体输入 $w$, 坐下来按转移表逐步模拟, 要么某步进入 $q_{accept}$, 要么发现它在兜圈子 — 人工模拟没有问题。

但问题在于: 如果模拟者本身也是一台机器, 且 $H$ 不停机, 那么模拟者也不会停机 — 它会跟着 $H$ 陷进去。

停机问题的要求是, 无论 $H$ 是否停机, 判定者本身​*必须停机*, 且必须给出正确答案。图灵、哥德尔、Cantor 的共同结论是: *做不到*​。

换句话说, 预测计算的难度, 和做计算本身一样难 — *没有捷径*​。​*计算没有捷径*

在物理学上, 这意味着不存在比宇宙演化更快的方式来预测宇宙的未来 — 预测本身就是一个与被预测过程等量的运算。

在生物学上, 不存在比完整模拟一个自动机更快的方式来预测它的成长 — 预测本身和模拟一样难。

** Implications for Program Analysis

停机问题对程序静态分析有直接推论: 不存在完全正确的编译器能在​*不运行程序*​的前提下, 保证检测出所有错误。除了完整运行一遍程序, 没有任何方法能保证验证其正确性 — 而程序本身可能死循环, 编译器不可能真的将其运行一遍。

*** Rice's Theorem

所有静态分析工具都面临一个不可能三角, 这一推论被称为 *Rice 定理*:

- 不漏报 (soundness)
- 不误报 (completeness)
- 能停机 (termination)

三者无法同时满足。各语言 / 工具的选择体现了对这一三角的不同取舍:

- /真正运行程序/: 保证不漏报、不误报, 但可能无法停机 (死循环)。
- *Rust*: 选择不漏报、能停机, 但可能误报 — 部分合法程序无法通过编译。
- *C++*: 选择不误报、能停机, 但大量错误会被静态分析跳过。

*** The Boundary

停机问题划定了一条明确的界限: 有些问题是​*机械不可解*​的 — 判断任意程序是否含有 bug、完全自动化任意工作流、模拟一个人类 — 这些在界限之外, 无法用确定性程序解决。

界限之内, 万物皆可; 界限之外, 无解。

能接受任意输入并给出有意义回答的系统, 走向概率方法大概是必然的 — 这正是神经网络的本质。LLM 的出现意味着, 大量以前无法被机械自动化的工作流, 如今有了近似解。


* Type System

** Overview

首先确定一个基调。我们有两个关于计算的模型: 图灵机与 $\lambda$ 演算。接下来的理论路线将沿着 *$\lambda$ 演算* 深入展开。理由是, 现代所有程序语言理论 (PL Theory) 的数学基础均建立在函数式模型之上, 包括 Type System 的数学基础 Curry-Howard 同构。

一门编程语言需要满足三个条件: 「人类可读性」、「精确」与「计算」。$\lambda$ 演算与图灵机已经同时解决了「精确」和「计算」。现在唯一需要解决的, 是「人类可读性」。

无类型的 $\lambda$ 演算 (Untyped Lambda Calculus) 在形式上是完备的: $\lambda$ 本身是唯一原语, 借助 Church encoding 可以编码 boolean、自然数及一切可计算结构。但它不符合人类的心智模型。表达式如 $\text{true} + 1$ 在无类型系统中语法合法、可以归约, 但对人类而言毫无语义意义——这是一种*语义错误*。

#+begin_quote
在无类型 $\lambda$ 演算中, 良型 (well-typed) 与良构 (well-formed) 是同一件事——语法合法即可归约, 系统对语义意义不加约束。
#+end_quote

由此会归约出越来越多的「垃圾值」(stuck terms)。

因此, 我们需要构建额外的​*数学结构*​来约束语言: 在推导过程中即可将特定的语义错误排除在外。这套结构就是 *Type System*

Type System 在设计上是​*保守的 (conservative)*​。在「不漏报、不误报、能停机」三者之间, 它选择牺牲「不误报」——宁可拒绝某些语义上无害的程序, 也绝不放过非法程序。

-----

** Simply Typed Lambda Calculus (STLC)

STLC 的核心思想只有一句话:

#+begin_quote
给每个 $\lambda$ 项贴上一个标签, 然后定义一套规则, 说明什么样的标签组合是合法的。
#+end_quote

这个「标签」就是​*类型 (Type)*

*** 语法

STLC 的类型语法定义如下:

$\tau ::= B \mid \tau_1 \to \tau_2$

- $B$ 为基础类型 (base type), 如 $\text{Bool}$, $\text{Nat}$ 等
- $\tau_1 \to \tau_2$ 为函数类型, 右结合, 完全柯里化

即 $\tau_1 \to \tau_2 \to \tau_3$ 解析为 $\tau_1 \to (\tau_2 \to \tau_3)$。

*** 类型环境

类型环境 (Typing Context) $\Gamma$ 是一个从变量到类型的有限映射:

$\Gamma ::= \emptyset \mid \Gamma, x : \tau$

它记录当前作用域内每个自由变量的类型假设。

*** 类型判断

类型判断 (Typing Judgment) 的形式记号为:

$\Gamma \vdash e : \tau$

读作: 「在上下文 $\Gamma$ 下, 项 $e$ 具有类型 $\tau$。」

*** 类型规则

STLC 的整个类型系统由三条推导规则构成。

*规则一 — 变量 (Var):*

$$\frac{x : \tau \in \Gamma}{\Gamma \vdash x : \tau}$$

若变量 $x$ 在环境 $\Gamma$ 中有类型假设, 则可直接判断其类型。

*规则二 — 函数抽象 (Abs):*

$$\frac{\Gamma, x : \tau_1 \vdash e : \tau_2}{\Gamma \vdash \lambda x{:}\tau_1.\ e : \tau_1 \to \tau_2}$$

在扩展了 $x : \tau_1$ 的环境下, 若体 $e$ 的类型为 $\tau_2$, 则整个抽象的类型为 $\tau_1 \to \tau_2$。

*规则三 — 函数应用 (App):*

$$\frac{\Gamma \vdash e_1 : \tau_1 \to \tau_2 \qquad \Gamma \vdash e_2 : \tau_1}{\Gamma \vdash e_1\ e_2 : \tau_2}$$

函数的参数类型必须与实参类型一致, 方可应用。

*** 类型安全 (Type Safety)

STLC 保证的类型安全由两个定理构成:

- *Progress*: 一个良型的项, 要么已经是值 (value), 要么还可以继续归约一步。不存在「卡住」的良型项。
- *Preservation*: 若 $\Gamma \vdash e : \tau$, 且 $e \to e'$, 则 $\Gamma \vdash e' : \tau$。归约一步后类型不变。

*** Curry-Howard 同构

观察 STLC 的类型规则, 可以发现一个深刻的对应关系。

- *函数应用 (App)* 对应逻辑学中的​*假言推理 (Modus Ponens)*: 已知 $A \Rightarrow B$ 与 $A$, 可推出 $B$
- *函数抽象 (Abs)* 对应逻辑学中的​*演绎定理 (Deduction Theorem)*: 在假设 $A$ 下能证明 $B$, 则可以证明 $A \Rightarrow B$
- *「已知蕴含与后件, 无法推出前件」* 对应​*肯定后件谬误 (Affirming the Consequent)*: 已知 $A \Rightarrow B$ 与 $B$, 不能推出 $A$

这就是 *Curry-Howard 同构*​。其核心断言如下:

#+begin_quote
*类型对应命题, 程序对应证明。写一个类型正确的程序, 就是在构造一个逻辑证明。编译器的类型检查器, 就是一个证明验证器。*
#+end_quote

*** 局限性

STLC 为保证类型安全, 放弃了​*参数多态性 (Parametric Polymorphism)*​。例如, 恒等函数 $\lambda x.\ x$ 在 STLC 中无法给出单一的多态类型 $\forall \alpha.\ \alpha \to \alpha$, 对每个具体类型都需要单独定义。

此外, Y 组合子在 STLC 中不可类型化, 这使得一般递归 (general recursion) 和无终止计算 (non-termination) 均无法在 STLC 中表达。这正是强规范化 (strong normalization) 的来源——所有良型项都必然停机。

这是安全的代价: 我们用​*表达力*​换来了​*安全性*​。

这引出下一个问题: 能否在保留表达力的同时, 也保留安全性?

-----

** System F: 让类型成为参数

在原始 $\lambda$ 演算中, 「值」是唯一的一等公民, 因为只有值可以被抽象为参数传递。在 STLC 中引入「类型」后, 类型仍然是二等公民——不能作为参数被抽象与传递。

System F 做的事情只有一件:

#+begin_quote
让类型也可以作为参数被抽象, 被传来传去。
#+end_quote

*** 语法扩展

在 STLC 的基础上, System F 新增两种构造:

类型层面的抽象与实例化:

$e ::= \ldots \mid \Lambda \alpha.\ e \mid e\ [\tau]$

$\tau ::= \ldots \mid \alpha \mid \forall \alpha.\ \tau$

- $\Lambda \alpha.\ e$: 类型抽象, 将类型变量 $\alpha$ 抽象为参数
- $e\ [\tau]$: 类型应用, 将具体类型 $\tau$ 传入

*** 类型规则

*规则四 — 类型抽象 (T-TAbs):*

$$\frac{\Gamma, \alpha \vdash e : \tau}{\Gamma \vdash \Lambda \alpha.\ e : \forall \alpha.\ \tau}$$

*规则五 — 类型应用 (T-TApp):*

$$\frac{\Gamma \vdash e : \forall \alpha.\ \tau}{\Gamma \vdash e\ [\tau'] : \tau[\tau' / \alpha]}$$

*** 逻辑对应

System F 在 Curry-Howard 对应下对应​*二阶命题逻辑 (Second-Order Propositional Logic)*​——命题可以对命题变量进行全称量化 $\forall \alpha.\ P(\alpha)$。

*** 代价: 类型推导不可判定

在 STLC 中, 给定一个项, 编译器可以自动推导出其类型。但在完整的 System F 中, 类型推导是不可判定的——必须手动标注 $\forall$ 类型, 编译器无法自动推断。

这就是为什么 Haskell 使用的不是完整的 System F, 而是其可判定子集 *Hindley-Milner (HM) 类型系统*​。HM 对 $\forall$ 的位置加以限制: $\forall$ 只能出现在类型的​*最外层 (prenex position)*, 从而使类型推导重新变得可判定, 并可通过 Algorithm W 高效实现。
