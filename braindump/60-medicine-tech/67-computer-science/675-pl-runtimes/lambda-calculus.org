#+title: The Nature of Computing: λ-calculus
#+author: SOV710
#+date: <2026-02-26 Thu>

* 编程语言的使命

首先, 我们为什么要编程语言?

从数电的布尔代数, 到打纸带再到汇编, 到 c, erlang, lisp, haskell, rust, 他们的最终「使命」是什么?

编程语言是人类意图与机器执行之间的翻译协议

更精确的说:

*编程语言的使命是以「人类」可以「精确」表达的形式, 描述「计算」过程*

- *人类可读性*: 语言需要符合人类的认知结构, 这就是为什么打纸带被完全淘汰了
- *精确*: 排除自然语言的歧义, 这就是为什么我们不能用自然语言编程
- *计算*: 这是所有编程语言的​*本质*, 每个编程语言必须在描述一种计算过程, 否则它就不是编程语言


今天, 我们不谈可读性, 只谈如何数学上「精确地」描述一种「计算过程」

* 什么是计算
直觉上, 计算就是 "按规则变换符号"。你有一些符号, 有一套规则, 然后你不断应用规则, 直到得到结果。

*图灵机*​和 *λ 演算*​两种独立的数学框架都独立捕捉到了这种直觉, 并且给出了两种「计算」的定义框架, 二者被证明完全等价

它们就是「计算」本身, 它们等价不代表它们在「计算能力」上等价, 图灵机的转移表完全可以由 $\lambda$ 演算的一个 $\beta$​-归约来完全表示

证明 $\lambda$ 演算能被图灵机表示有个比理论更直观的方式, 那就是 lisp 和 haskell 已经在图灵机的物理实现 —— 现代计算机 —— 上工作了, 理论推导也简单, $\lambda$ 归约是 $\beta$​-归约: 找到一个 ​$(\lambda x.\, e_1)\; e_2$, 做代换

这个操作完全可以被图灵机机械地执行:
1. 把λ表达式编码为纸带上的字符串（括号+字母）
2. 扫描纸带, 找到最左边的 redex（可归约项）
3. 执行代换：找到 $e_1$ 里所有 $x$ 的出现, 替换为 $e_2$
4. 重复, 直到没有 redex

** Turing Machine

*** Formal Definition

一台图灵机是一个七元组 :

$M = (Q, \Sigma, \Gamma, \delta, q_0, q_{accept}, q_{reject})$

- $Q$ —— 有限状态集
- $\Sigma$ —— 输入字母表 ( 不含空白符 )
- $\Gamma$ —— 纸带字母表, $\Sigma \subset \Gamma$, 含空白符 $\sqcup$
- $\delta: Q \times \Gamma \to Q \times \Gamma \times \{L, R\}$ —— 转移函数
- $q_0 \in Q$ —— 初始状态
- $q_{accept}, q_{reject} \in Q$ —— 接受 / 拒绝状态

**** Configuration

*格局 (Configuration)* 是计算在某一时刻的完整快照 :

$C = uqv \quad u,v \in \Gamma^*, q \in Q$

表示纸带内容为 $uv$, 读写头在 $v$ 的第一个字符处, 当前状态为 $q$。

**** One-Step Transition

*一步转移*​定义为格局之间的关系 $\vdash$ :

$ua\,q\,bv \;\vdash\; uaq'cv \quad \text{if } \delta(q,b) = (q', c, R)$

$uaq\,bv \;\vdash\; u\,q'acv \quad \text{if } \delta(q,b) = (q', c, L)$

**** Computation

*计算*​是格局的序列 :

$C_0 \vdash C_1 \vdash C_2 \vdash \cdots$

当到达 $q_{accept}$ 或 $q_{reject}$ 时终止。

*** Computational Intuition

图灵机捕捉的是 *工人按操作手册工作* 的直觉。

有一条无限长的纸带 (内存), 一个读写头 (程序计数器 + ALU), 一本操作手册 (转移函数)。工人在任意时刻只做一件事: 看当前格子写的什么, 查手册, 改写这格, 往左或往右移一步, 换一个心理状态。

计算的关键特征:

- *局部性*: 每一步只依赖当前状态和当前符号
- *顺序性*: 步骤严格线性推进
- *有状态性*: 结果是全局状态的演变

#+begin_quote
图灵机回答的问题是: 什么问题是机器可以解决的 ?
#+end_quote

这非常接近真实硬件的工作方式 —— 寄存器, 内存, 程序计数器, 本质上就是图灵机的物理实现。

** Lambda Calculus

*** Formal Definition

**** Syntax

项的归纳定义 :

$e ::= x \mid \lambda x.\, e \mid e_1\; e_2$

三条构造, 仅此而已 : 变量, 函数抽象, 函数应用。

**** Free Variables

$FV(x) = \{x\}$

$FV(\lambda x.\, e) = FV(e) \setminus \{x\}$

$FV(e_1\; e_2) = FV(e_1) \cup FV(e_2)$

**** Substitution

*代换* (capture-avoiding substitution) $e_1[x := e_2]$ : 将 $e_1$ 中 $x$ 的自由出现替换为 $e_2$, 必要时做 $\alpha$​-重命名以避免变量捕获。

**** Reduction Rules

1. $\alpha$-conversion : $\lambda x.\, e \;\to_\alpha\; \lambda y.\, e[x := y] \quad (y \notin FV(e))$
2. $\beta$-reduction : $(\lambda x.\, e_1)\; e_2 \;\to_\beta\; e_1[x := e_2]$
3. $\eta$-reduction : $\lambda x.\, (e\; x) \;\to_\eta\; e \quad (x \notin FV(e))$

其中 $\beta$​-reduction 是计算的核心, $\alpha$ 只是重命名, $\eta$ 表达函数的外延相等。

**** Computation

计算是项在 $\to_\beta$ 下的归约序列 :

$e_0 \to_\beta e_1 \to_\beta e_2 \to_\beta \cdots$

当项无法继续 $\beta$​-归约时, 称其为 *$\beta$​-范式 ( $\beta$​-normal form )*, 计算结束。

**** Church-Rosser Theorem

*合流性 ( Confluence )* :

$e \twoheadrightarrow e_1 \text{ and } e \twoheadrightarrow e_2 \implies \exists\, e_3,\; e_1 \twoheadrightarrow e_3 \text{ and } e_2 \twoheadrightarrow e_3$

即无论选择什么归约顺序, 如果最终能到达范式, 范式是唯一的。

*** Church Encoding

一切皆函数。数字与布尔值均可编码为纯 $\lambda$ 项 :

- $\mathbf{0} = \lambda f.\, \lambda x.\, x$
- $\mathbf{1} = \lambda f.\, \lambda x.\, f\; x$
- $\mathbf{true} = \lambda t.\, \lambda f.\, t$
- $\mathbf{false} = \lambda t.\, \lambda f.\, f$

这意味着, 没有比 $\lambda$ 更加底层的公理和定义了, 没有类型了, $\lambda$ 就是最底层的原语

*** Computational Intuition

$\lambda$ 演算捕捉的是 *代入与化简* 的直觉, 就像在数学课上化简表达式一样。

$(\lambda x.\, x + 1)\; 5$ 的意思是"把 5 代入 $x+1$", 结果是 $6$。没有内存, 没有状态, 没有时间顺序 —— 只有表达式, 和表达式之间的等价关系。

计算的关键特征:

- *无状态性*: 程序是数学对象, 不存在可变内存
- *代换即执行*: 函数应用的语义完全由代换定义
- *等价而非过程*: 执行是寻找范式, 而非追踪步骤

#+begin_quote
$\lambda$ 演算回答的问题是: 计算的代数结构是什么 ?
#+end_quote

-----

** Comparison

图灵机的基本操作是 *赋值* (改写纸带), $\lambda$ 演算的基本操作是 *代换* (函数应用)。

以下为两者核心维度的对比 :

- *计算的载体* : 图灵机使用状态 + 纸带 ; $\lambda$ 演算使用表达式
- *一步计算* : 图灵机执行状态转移 ; $\lambda$ 演算执行 $\beta$-归约
- *计算的结果* : 图灵机输出纸带上的内容 ; $\lambda$ 演算输出范式
- *时间观* : 图灵机有显式的步骤序列 ; $\lambda$ 演算的时间隐式于归约关系中
- *内存观* : 图灵机有显式内存 ( 纸带 ) ; $\lambda$ 演算中内存不存在
- *对应范式* : 图灵机对应命令式编程 ; $\lambda$ 演算对应函数式编程

这两个操作之间的张力, 就是命令式编程和函数式编程之间几十年争论的根源。

* Halting Problem

** Formal Definition

图灵机是一个七元组 $H = (Q, \Sigma, \Gamma, \delta, q_0, q_{accept}, q_{reject})$, 其中:

- $Q$ 是有限状态集
- $\Sigma$ 是输入字母表, 满足 $\sqcup \notin \Sigma$
- $\Gamma$ 是纸带字母表, 满足 $\Sigma \subseteq \Gamma$ 且 $\sqcup \in \Gamma$
- $\delta : (Q \setminus \{q_{accept}, q_{reject}\}) \times \Gamma \to Q \times \Gamma \times \{L, R\}$ 是转移函数
- $q_0 \in Q$ 是初始状态
- $q_{accept} \in Q$ 是接受状态
- $q_{reject} \in Q$ 是拒绝状态, 且 $q_{reject} \neq q_{accept}$

*停机问题*​定义为判定以下语言是否可判定:

$HALT = \{ \langle H, w \rangle \mid H \text{ halts on input } w \}$

*定理 (Turing, 1936)*: $HALT$ 是不可判定的, 即不存在图灵机能判定 $HALT$。


** Intuition

停机问题的直觉等价于如下场景: 假设有一个工人, 完全知晓某台机器的转移规则, 也知道该机器即将接受的输入, 让它进行完全机械的逐步推导 — 它能否判断该机器最终会停机？

在某种意义上, 这是可行的。给定 $H$ 和具体输入 $w$, 坐下来按转移表逐步模拟, 要么某步进入 $q_{accept}$, 要么发现它在兜圈子 — 人工模拟没有问题。

但问题在于: 如果模拟者本身也是一台机器, 且 $H$ 不停机, 那么模拟者也不会停机 — 它会跟着 $H$ 陷进去。

停机问题的要求是, 无论 $H$ 是否停机, 判定者本身​*必须停机*, 且必须给出正确答案。图灵、哥德尔、Cantor 的共同结论是: *做不到*​。

换句话说, 预测计算的难度, 和做计算本身一样难 — *没有捷径*​。​*计算没有捷径*

在物理学上, 这意味着不存在比宇宙演化更快的方式来预测宇宙的未来 — 预测本身就是一个与被预测过程等量的运算。

在生物学上, 不存在比完整模拟一个自动机更快的方式来预测它的成长 — 预测本身和模拟一样难。

** Implications for Program Analysis

停机问题对程序静态分析有直接推论: 不存在完全正确的编译器能在​*不运行程序*​的前提下, 保证检测出所有错误。除了完整运行一遍程序, 没有任何方法能保证验证其正确性 — 而程序本身可能死循环, 编译器不可能真的将其运行一遍。

*** Rice's Theorem

所有静态分析工具都面临一个不可能三角, 这一推论被称为 *Rice 定理*:

- 不漏报 (soundness)
- 不误报 (completeness)
- 能停机 (termination)

三者无法同时满足。各语言 / 工具的选择体现了对这一三角的不同取舍:

- /真正运行程序/: 保证不漏报、不误报, 但可能无法停机 (死循环)。
- *Rust*: 选择不漏报、能停机, 但可能误报 — 部分合法程序无法通过编译。
- *C++*: 选择不误报、能停机, 但大量错误会被静态分析跳过。

*** The Boundary

停机问题划定了一条明确的界限: 有些问题是*机械不可解*的 — 判断任意程序是否含有 bug、完全自动化任意工作流、模拟一个人类 — 这些在界限之外, 无法用确定性程序解决。

界限之内, 万物皆可; 界限之外, 无解。

能接受任意输入并给出有意义回答的系统, 走向概率方法大概是必然的 — 这正是神经网络的本质。LLM 的出现意味着, 大量以前无法被机械自动化的工作流, 如今有了近似解。


* Type System

** Overview

首先确定一个基调, 我们现在有两个关于计算的模型, 图灵机和 $\lambda$ 演算，接下来我们要走 *$\lambda$ 演算*​的模型深入, 理由很简单, 现代所有 PL 理论的数学基础都是基于函数式, 基于 $\lambda$ 演算的, 包括 Type System 的数学基础 Curry-Howard 同构

之前, 我们定义了一个编程语言需要什么, 「人类可读性」「精确」和「计算」, 现在我们同时解决了「精确」和「计算」, 我们有图灵机和 $\lambda$ 演算这两个世界上最强大的武器。现在, 唯一需要解决的是 「人类可读性」

无类型的 $\lambda$ 演算确实可以用，$\lambda$ 本身就是唯一的原语, 我们用 $\lambda$ 表示 boolean, 借助 Church encoding 我们可以编码所有 int 数字, 我们可以用 $\lambda$ 做所有的计算

但是，最大的问题是, $\lambda$ 不符合人类的心智模型, 人类需要计算数值, 需要计算 boolean, 但我们明显不能容忍 true + 1 这种, 逻辑上完全正确, 但对人类毫无意义的算式出现, 简而言之, 这是个语义错误

在无类型 $\lambda$ 演算中, 良型 (well-typed) 和 良构 (well-formed) 是同一件事——只要语法合法，就可以归约。

但语义上的意义，系统完全不管。大体上来说, 我们会归约出来越来越多的垃圾值

所以我们要构建更多的, 关于类型的​*数学结构*, 用来限制语言本身在推导的过程中, 就能把这种特定的​*语义错误*​排除

Type System 是保守的, 在「不漏报, 不误报, 能停机」中选择了牺牲「不误报」，宁可拒绝某些正常程序, 也不放过非法程序

** Simply Typed Lambda Calculus (STLC)

我们要做的事情只有一件:

#+begin_quote
给每个λ项贴上一个标签，然后定义一套规则，说明什么样的标签组合是合法的。
#+end_quote

这个"标签"就是类型。

STLC 的语法定义如下: (略)

只有两种构造, 基础类型, 和类型的函数结构, 注意后者是右结合的, 完全柯里化

第二步: 类型环境

形式定义: xxx

第三步: 类型判断

形式记号: xxxx

第四步: 类型规则

形式; xxx

规则一, 规则二，规则三

变量, 函数抽象, 函数应用

整个 STLC 的类型系统就是这三条规则

简单示例应用: xxx

STLC 保证的​*类型安全* (Type Safety) 由两个自定义构成
- Progress: 一个良型的项，要么已经是值，要么还能继续归约
- Preservation: 归约一步之后，类型不变


*** Curry-Howard


STLC 给我的感觉像是逻辑学中的蕴含, 知道前项和蕴含可以推导出后项, 知道前项和后项也可以推导出蕴含, 但知道蕴含和后项无法推导出前项

具体来说, STLC 的类型应用，就是逻辑学里的假言推理（Modus Ponens）

STLC 的函数抽象, 就是逻辑学里的演绎定理（Deduction Theorem）

"知道蕴含和后项无法推导出前项", 这对应的是逻辑学里的肯定后件谬误（Affirming the Consequent）

这就是 *Curry-Howard 同构*

Curry-Howard 告诉我们：

*写一个类型正确的程序，就是在构造一个逻辑证明。编译器的类型检查器，就是一个证明验证器。*

*** 局限

STLC 失去为了保证类型完全安全, 失去了类型多态性 (Parametric Polymorphism), 具体来说就是

并且, 在 STLC 中不可能停机, 因为 Y 组合子在 STLC 中是不可类型化的, 这也让我们不可能写出死循环

这就是安全的代价, 我们用表达力换来了安全性

这引出了下一个问题: 能否在保留表达力的同时, 保留安全性?


** System F: 让类型成为参数

在原始的 $\lambda$ 演算中, 我们只有 $\lambda$, 在 $\lambda$ 中只有「值」是一等公民, 因为只有值可以被抽象为一个参数传来传去

但是, 在 STLC 中引入「类型」后, 我们并没有给予类型相同的地位，我们不能将类型作为参数传来传去

System F 做的事情只有一件:

让类型也可以作为参数被抽象, 被传来传去

语法拓展: xxx

类型规则: xxx

System F 在命题逻辑中对应的是二阶命题逻辑——命题可以对命题变量进行量化

规则四, 规则五

示例

*** System F 的代价

类型推导不可判定。 在 STLC 里，给定一个项，编译器可以自动推导出它的类型。在 System F 里，你必须手动标注类型——编译器无法自动推断完整的 $\forall$ 类型

这就是为什么 Haskell 使用的不是完整的 System F，而是它的一个可判定的子集，叫做 Hindley-Milner 类型系统——它限制了 $\forall$ 只能出现在类型的最外层，从而使类型推导重新变得可判定
