#+title: Network Protocols Deep Dive: From Link Layer to Application Layer
#+author: SOV710
#+date: 2025-12-24
#+startup: showall
#+options: toc:2 num:nil

* 网络分层模型: 从理论到实践

网络协议栈的分层设计是计算机网络的核心思想。不同的模型有不同的抽象层级, 但本质都是为了 *模块化* 和 *解耦*​。

** OSI 七层模型: 理想化的参考框架

OSI (Open Systems Interconnection) 七层模型是 ISO 在 1984 年制定的理论模型, 虽然实际实现很少完全遵循, 但它提供了一个清晰的概念框架。

| 层级 | 名称                 | 功能简述                | 典型协议/技术          |
|------+----------------------+------------------------+----------------------|
|    7 | 应用层 (Application)  | 为用户提供网络服务        | HTTP, FTP, SMTP, DNS |
|    6 | 表示层 (Presentation) | 数据格式化、加密、压缩     | TLS, JPEG, MPEG      |
|    5 | 会话层 (Session)      | 建立、管理和终止会话连接    | NetBIOS, RPC         |
|    4 | 传输层 (Transport)    | 端到端通信, 可靠性控制     | TCP, UDP             |
|    3 | 网络层 (Network)      | 路由与寻址, 跨网络传输     | IP, ICMP, OSPF, BGP  |
|    2 | 数据链路层 (Data Link) | 帧传输、错误检测、MAC 寻址 | Ethernet, Wi-Fi, PPP |
|    1 | 物理层 (Physical)     | 传输比特流, 物理介质规范   | 电缆, 光纤, 无线信号    |

*** 为什么 OSI 没有成为事实标准？

- *过于复杂*: 七层划分在实践中过于细粒度, 5/6/7 层的边界模糊
- *TCP/IP 先行*: Internet 的成功使得 TCP/IP 成为事实标准
- *性能开销*: 严格分层会增加封装/解封装的开销

但 OSI 模型仍然是 *教学* 和 *问题诊断* 的重要工具 ("七层网络问题排查")。

** 四层模型 (TCP/IP 模型): 工程实践的选择

Stanford CS144 和实际 Internet 使用的是更简化的四层模型, 也叫 TCP/IP 模型或 Internet 协议栈。

| 层级 | 名称                | 典型协议         | 主要功能            | 与 OSI 对应 |
|------+---------------------+-----------------+--------------------+------------|
|    4 | 应用层 (Application) | HTTP, SMTP, DNS | 定义应用程序语义      |        5-7 |
|    3 | 传输层 (Transport)   | TCP, UDP        | 可靠性、流控、拥塞控制 |          4 |
|    2 | 网络层 (Network)     | IP, ICMP        | 端到端路由和寻址      |          3 |
|    1 | 链路层 (Link)        | Ethernet, Wi-Fi | 单跳帧传输           |        1-2 |

*** 封装原理: 洋葱模型

每层在发送数据时, 会在上一层的数据外面 *加上自己的 header* (有时还有 trailer)。

#+begin_example
应用层数据: "GET / HTTP/1.1"
  ↓ 加 TCP header
TCP 段: [TCP header | "GET / HTTP/1.1"]
  ↓ 加 IP header
IP 数据报: [IP header | TCP header | "GET / HTTP/1.1"]
  ↓ 加 Ethernet header/trailer
以太网帧: [Eth header | IP header | TCP header | "GET / HTTP/1.1" | Eth trailer]
#+end_example

*关键规则*: 网络的层级越高, 封装的就越外层。接收方按相反顺序解封装。

*** 端到端原则 (End-to-End Principle)

Internet 设计的核心哲学之一:

#+begin_quote
如果某个功能 *可以* 在端点 (源和目的主机) 实现, 就 *应该* 在端点实现, 而不是在网络中间节点实现。
#+end_quote

这就是为什么:

- IP 层不提供可靠性 (留给 TCP)
- 路由器不做流量控制 (留给传输层)
- 加密在端点做 (TLS), 而不是在路由器

*优势*:

- 网络核心简单、快速
- 灵活性高 (应用可以自己选择传输层协议)
- 扩展性好 (不需要升级所有路由器)

** Endianness: 字节序的陷阱

计算机内部存储多字节数据 (如 32 位整数) 时, 有两种字节顺序:

- *大端序* (Big-Endian): 高位字节存在低地址 (人类习惯的阅读顺序)
- *小端序* (Little-Endian): 低位字节存在低地址 (x86/x64 处理器的默认方式)

*** 示例: 存储 0x12345678

#+begin_example
地址:     0x1000  0x1001  0x1002  0x1003
大端序:   0x12    0x34    0x56    0x78
小端序:   0x78    0x56    0x34    0x12
#+end_example

*** 网络字节序 = 大端序

*所有网络协议* (IP, TCP, UDP) 都规定使用 *大端序* (也叫 Network Byte Order)。

#+begin_src c
#include <arpa/inet.h>

uint32_t host_value = 0x12345678;

// 主机序 → 网络序 (host to network long)
uint32_t net_value = htonl(host_value);

// 网络序 → 主机序 (network to host long)
uint32_t host_value2 = ntohl(net_value);
#+end_src

在小端机器 (x86) 上, =htonl()= 会做字节翻转; 在大端机器上, 它是空操作。

*常见错误*:

#+begin_src cpp
// 错误: 直接用主机序发送
uint16_t port = 8080;
send(sockfd, &port, 2, 0);  // 在小端机器上发送的是 0x901f, 而不是 0x1f90

// 正确: 转换为网络序
uint16_t port_net = htons(8080);
send(sockfd, &port_net, 2, 0);
#+end_src

* IP: Internet 的基石

IP (Internet Protocol) 是网络层的核心协议, 定义了如何在全球范围内寻址和路由数据包。

** IP 的三个核心特性

*** 1. Datagram (数据报): 自包含的独立单元

每个 IP 数据报都携带了 *完成独立传输所需的全部信息*:

- *源 IP 地址* (IP SA, Source Address)
- *目的 IP 地址* (IP DA, Destination Address)
- *TTL* (Time To Live, 防止无限循环)
- *协议类型* (上层是 TCP 还是 UDP?)
- *数据载荷*

这意味着路由器只需查看单个数据报的 IP 头, 就能决定如何转发它, 无需维护连接状态。

*** 2. Unreliable (不可靠): 尽力而为, 不保证送达

IP 不提供任何 *可靠性保证*:

- 数据报可能 *丢失* (路由器队列满了就丢弃)
- 数据报可能 *乱序* (不同路径延迟不同)
- 数据报可能 *重复* (某些路由协议会复制包)
- 数据报可能 *损坏* (虽然有校验和, 但只检测头部)

*为什么这么设计？*

- 简单 → 快速 (路由器不需要维护连接状态)
- 端到端原则 (可靠性由 TCP 在端点保证)
- 灵活性 (UDP 应用不需要可靠性)

*** 3. Connectionless (无连接): 每个包独立处理

IP 不建立 "连接" (connection), 每个数据报都是独立的:

- 发送方直接发送, 不需要 "握手"
- 路由器不记录 "这个包属于哪个流"
- 两个连续的数据报可能走不同的路径

这与电话网络的 *电路交换* (circuit switching) 形成对比。

** IP 的关键机制

*** TTL: 防止路由环路

每个 IP 数据报都有一个 *TTL* 字段 (IPv4 中是 8 位, 取值 0-255)。

*工作原理*:

1. 发送方设置初始 TTL (通常是 64 或 128)
2. 每经过一个路由器, TTL *减 1*
3. 如果 TTL 降到 0, 路由器 *丢弃* 该数据报, 并发送 ICMP "Time Exceeded" 消息

*用途*:

- 防止路由环路导致的无限循环
- =traceroute= 工具利用 TTL 来探测路径 (发送 TTL=1, 2, 3... 的包)

#+begin_src bash
$ traceroute google.com
 1  192.168.1.1 (192.168.1.1)  1.234 ms
 2  10.0.0.1 (10.0.0.1)  5.678 ms
 3  ...
#+end_src

*** 分片 (Fragmentation): 适应不同 MTU

不同链路层有不同的 *MTU* (Maximum Transmission Unit, 最大传输单元):

- Ethernet: 1500 字节
- PPPoE: 1492 字节
- Jumbo Frame: 9000 字节

如果 IP 数据报 *大于* 链路的 MTU, 路由器会将其 *分片*:

#+begin_example
原始数据报 (3000 字节)
  ↓ 遇到 MTU=1500 的链路
分片 1 (1500 字节, offset=0, MF=1)
分片 2 (1500 字节, offset=1480, MF=1)
分片 3 (20 字节, offset=2960, MF=0)
#+end_example

*IPv4 头部字段*:

- =Identification=: 分片属于哪个原始数据报
- =Flags=: =MF= (More Fragments) 位, 表示后面还有分片
- =Fragment Offset=: 该分片在原始数据中的字节偏移 (以 8 字节为单位)

*IPv6 的改进*:

IPv6 *禁止* 路由器分片, 只允许源主机分片。如果数据报太大, 路由器发送 ICMP "Packet Too Big" 消息, 源主机重新调整。

*Path MTU Discovery (PMTUD)*:

现代系统通过发送 "Don't Fragment" (DF) 标志的数据报, 探测路径上的最小 MTU, 从而避免分片。

*** Header Options: 很少使用的扩展

IPv4 允许在头部添加可选字段 (如 Timestamp, Record Route), 但 *几乎没人用*:

- 增加处理复杂度 (路由器要检查可变长度头部)
- 安全风险 (某些选项可被用于攻击)
- IPv6 已经废弃了这个机制

** 路由转发: Longest Prefix Match

每个路由器维护一张 *转发表* (Forwarding Table), 描述 "目的 IP 前缀 → 出接口" 的映射。

*** 示例转发表

| 目的网络前缀          | 下一跳 / 出接口      |
|---------------------|-------------------|
| 192.168.1.0/24      | eth0              |
| 10.0.0.0/8          | 10.0.0.1          |
| 172.16.0.0/12       | 172.16.0.1        |
| 0.0.0.0/0 (default) | 203.0.113.1       |

*** Longest Prefix Match (LPM)

当数据报到达时, 路由器:

1. 提取目的 IP 地址
2. 在转发表中 *找到所有匹配的前缀*
3. 选择 *掩码位数最多* (前缀最长) 的那一条

*示例*:

目的 IP: =192.168.1.100=

匹配项:
- =192.168.1.0/24= (24 位匹配)
- =192.168.0.0/16= (16 位匹配)
- =0.0.0.0/0= (0 位匹配, 默认路由)

选择: =192.168.1.0/24= → 从 =eth0= 转发

*** 为什么是 "最长" 前缀？

因为前缀越长, 匹配越 *具体*。类比文件系统:

- =/home/user/docs/file.txt= (最具体)
- =/home/user/= (次具体)
- =/= (最宽泛)

** IPv4: 地址耗尽的遗产

*** IPv4 头部结构

#+begin_example
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |Version|  IHL  |Type of Service|          Total Length         |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |         Identification        |Flags|      Fragment Offset    |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |  Time to Live |    Protocol   |         Header Checksum       |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                       Source Address                          |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                    Destination Address                        |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                    Options                    |    Padding    |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#+end_example

*关键字段*:

- *Version*: 始终为 4
- *IHL* (Internet Header Length): 头部长度 (以 4 字节为单位, 最小值 5 = 20 字节)
- *Type of Service (ToS)*: 现在叫 DSCP/ECN, 用于 QoS
- *Total Length*: 整个数据报长度 (头部 + 数据, 最大 65535 字节)
- *Protocol*: 上层协议 (TCP=6, UDP=17, ICMP=1)
- *Header Checksum*: 只校验头部, 不校验数据 (每跳都要重新计算, 因为 TTL 变化)

*** 子网掩码 (Netmask): 划分网络和主机

子网掩码用连续的 1 表示 *网络位*, 连续的 0 表示 *主机位*。

*示例*: =192.168.1.100/24=

#+begin_example
IP 地址:   11000000.10101000.00000001.01100100  (192.168.1.100)
子网掩码:  11111111.11111111.11111111.00000000  (255.255.255.0)
           ↑------------------------↑ ↑------↑
           网络位 (24 位)              主机位 (8 位)

网络地址:  192.168.1.0    (主机位全 0)
广播地址:  192.168.1.255  (主机位全 1)
可用主机:  192.168.1.1 ~ 192.168.1.254 (254 个)
#+end_example

*同一网络的判断*:

两个 IP 地址 =IP1= 和 =IP2= 在同一网络, 当且仅当:

#+begin_example
(IP1 & Netmask) == (IP2 & Netmask)
#+end_example

*** IPv4 地址分配的演变

*1. 分类地址 (Classful Addressing, 1981-1993)*

早期 Internet 将 IP 地址分为 A/B/C 三类, 根据首字节判断:

| 类别 | 首字节范围  | 网络位 | 主机位 | 网络数量     | 每网络主机数    | 示例网络        |
|----+-----------+------+------+------------+------------+---------------|
| A  | 0-127     | 8    | 24   | 128        | 16,777,216 | 10.0.0.0/8    |
| B  | 128-191   | 16   | 16   | 16,384     | 65,536     | 172.16.0.0/16 |
| C  | 192-223   | 24   | 8    | 2,097,152  | 256        | 192.168.1.0/24|

*问题*:

- A 类太大 (1600 万主机), B 类太大 (6.5 万主机), C 类太小 (256 主机)
- 浪费严重 (一个公司申请 B 类, 但只用几千个 IP)
- 1990 年代初已预见地址耗尽

*2. CIDR (Classless Inter-Domain Routing, 1993-今)*

CIDR 抛弃了固定的 A/B/C 分类, 允许 *任意长度* 的网络前缀。

*表示法*: =IP地址/前缀长度=

- =255.0.0.0/8=: $2^{24}$ 个主机 (A 类等价)
- =255.255.240.0/20=: $2^{12}$ = 4096 个主机
- =255.255.255.252/30=: $2^2$ = 4 个主机 (点对点链路)

*优势*:

- 灵活分配 (可以给公司分配 =/20= 而不是整个 B 类)
- 路由聚合 (Supernetting): 多个小网络可以合并为一个大前缀, 减少路由表条目

*** IPv4 地址分配机构

全球 IPv4 地址由以下机构分层管理:

1. *ICANN* (Internet Corporation for Assigned Names and Numbers): 最高权威
2. *IANA* (Internet Assigned Numbers Authority): ICANN 下属, 负责全球地址池
3. *RIR* (Regional Internet Registry): 五大区域注册机构

*五大 RIR 及其覆盖区域*:

| RIR      | 覆盖区域          | 典型分配的 /8 块示例                                       |
|----------+------------------+---------------------------------------------------------|
| ARIN     | 北美 + 部分加勒比   | 23/8, 24/8, 50/8, 63-76/8, 96-99/8, 104/8, 107-108/8... |
| RIPE NCC | 欧洲 + 中东 + 中亚 | 2/8, 5/8, 31/8, 37/8, 46/8, 62/8, 77-95/8, 109/8...     |
| APNIC    | 亚太地区          | 1/8, 14/8, 27/8, 36/8, 39/8, 42/8, 49/8, 58-61/8...     |
| LACNIC   | 拉丁美洲 + 加勒比   | 177/8, 179/8, 181/8, 186/8, 187/8, 189/8, 190/8...      |
| AFRINIC  | 非洲             | 41/8, 102/8, 105/8, 197/8                               |

- ARIN: 23/8, 24/8, 50/8, 63/8, 64/8, 65/8, 66/8, 67/8, 68/8, 69/8, 70/8, 71/8, 72/8, 73/8, 74/8, 75/8, 76/8, 96/8, 97/8, 98/8, 99/8, 100/8, 104/8, 107/8, 108/8, 173/8, 174/8, 184/8, 199/8, 204/8, 205/8, 206/8, 207/8, 208/8, 209/8, 216/8
- RIPE NCC: 2/8, 5/8, 31/8, 37/8, 46/8, 62/8, 77/8, 78/8, 79/8, 80/8, 81/8, 82/8, 83/8, 84/8, 85/8, 86/8, 87/8, 88/8, 89/8, 90/8, 91/8, 92/8, 93/8, 94/8, 95/8, 109/8, 176/8, 178/8, 185/8, 193/8, 194/8, 195/8, 212/8, 213/8, 217/8
- APNIC: 1/8, 14/8, 27/8, 36/8, 39/8, 42/8, 49/8, 58/8, 59/8, 60/8, 61/8, 101/8, 103/8, 106/8, 110/8, 111/8, 112/8, 113/8, 114/8, 115/8, 116/8, 117/8, 118/8, 119/8, 120/8, 121/8, 122/8, 123/8, 124/8, 125/8, 126/8, 175/8, 180/8, 182/8, 183/8, 202/8, 203/8, 210/8, 211/8, 218/8, 219/8, 220/8, 221/8, 222/8, 223/8
- LACNIC: 177/8, 179/8, 181/8, 186/8, 187/8, 189/8, 190/8, 200/8, 201/8
- AFRINIC: 41/8, 102/8, 105/8, 197/8

*特殊分配: A 类地址的遗产*

早期 Internet 将整个 /8 块分配给了单个机构, 其中许多至今仍然保留:

*商业机构*:

| /8 网段 | 机构                      | 备注                  |
|---------+---------------------------+-----------------------|
| 3/8     | General Electric Company  | 现已部分回收            |
| 12/8    | AT&T Services             | ARIN 直接分配 (legacy) |
| 15/8    | Hewlett-Packard           | 现 HP Enterprise      |
| 16/8    | Digital Equipment Corp    | 现已被 HP 吸收          |
| 17/8    | Apple Inc.                | ARIN 直接分配          |
| 18/8    | MIT                       | 已归还, 现为公共地址池    |
| 19/8    | Ford Motor Company        | ——                    |
| 35/8    | Merit Network (early NSF) | 已归还                 |
| 38/8    | Cogent Communications     | ——                    |
| 53/8    | Mercedes-Benz Group AG    | RIPE "LEGACY" 资源    |

*政府/军方*:

| /8 网段       | 机构                                |
|---------------+-------------------------------------|
| 6/8, 7/8      | U.S. Army / DoD Network Info Center |
| 11/8          | DoD Intel Information Systems       |
| 21/8, 22/8    | Defense Information Systems Agency  |
| 26/8, 28-30/8 | DoD / DISA                          |
| 33/8          | DLA Systems Automation Center       |
| 55/8          | DoD (曾属 Boeing, 后转回)             |
| 214/8, 215/8  | DoD                                 |
| 25/8          | UK Ministry of Defence (RIPE 维护)  |

*著名的 10/8: Stanford 的馈赠*

- 1980 年代初, Stanford 被分配了 =10.0.0.0/8= (A 类地址)
- 后来 Stanford 将其归还, 现在 =10.0.0.0/8= 是 *RFC 1918 私有地址* 之一
- 其他私有地址块: =172.16.0.0/12=, =192.168.0.0/16=

*2011 年: IPv4 地址正式耗尽*

2011 年 2 月 3 日, IANA 将最后 5 个 /8 块分配给 RIRs, 标志着 IPv4 中央地址池耗尽。各 RIR 随后在 2011-2020 年间陆续耗尽其区域地址池。

*** IPv4 的应对措施

*1. NAT (Network Address Translation)*

允许多个设备共享一个公网 IP:

#+begin_example
内网设备:
  - 192.168.1.10:5000
  - 192.168.1.11:5001
    ↓ NAT 路由器
公网 IP: 203.0.113.5:12345
#+end_example

*缺点*:

- 打破端到端原则 (无法直接从外网访问内网设备)
- 某些协议 (如 FTP, SIP) 需要特殊处理
- 增加延迟和复杂度

*2. IPv6 迁移*

根本解决方案, 但部署缓慢 (见下节)。

** IPv6: 地址空间的终极解决方案

IPv6 使用 *128 位* 地址, 提供 $2^{128} \approx 3.4 \times 10^{38}$ 个地址 (足够给地球上每粒沙子分配一个 IP)。

*** IPv6 头部结构

#+begin_example
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |Version| Traffic Class |           Flow Label                  |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |         Payload Length        |  Next Header  |   Hop Limit   |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               |
 +                                                               +
 |                                                               |
 +                         Source Address                        +
 |                                                               |
 +                                                               +
 |                                                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               |
 +                                                               +
 |                                                               |
 +                      Destination Address                      +
 |                                                               |
 +                                                               +
 |                                                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#+end_example

*关键改进*:

- *固定 40 字节*: 无可选字段, 简化路由器处理
- *无分片*: 路由器不再分片, 只发送 ICMP Packet Too Big
- *无校验和*: 依赖链路层和传输层, 减少路由器负担
- *扩展头部*: 可选功能通过 "Next Header" 链式连接 (如 Routing, Fragment, Authentication)

*** IPv6 地址表示

*标准格式*: 8 组 4 位十六进制数, 用冒号分隔

#+begin_example
2001:0db8:85a3:0000:0000:8a2e:0370:7334
#+end_example

*压缩规则*:

1. 省略前导 0: =2001:0db8:0001:0000= → =2001:db8:1:0=
2. 连续的 0 组可以用 =::= 代替 (只能用一次):

#+begin_example
2001:0db8:0000:0000:0000:0000:0000:0001
  ↓
2001:db8::1
#+end_example

*特殊地址*:

- =::1/128=: 环回地址 (等价于 IPv4 的 127.0.0.1)
- =::/128=: 未指定地址
- =fe80::/10=: 链路本地地址 (Link-Local, 类似 169.254.0.0/16)
- =2000::/3=: 全球单播地址 (Global Unicast, 公网地址)

*** IPv6 的现状

*部署进展*:

- Google 统计 (2024 年): 全球约 *40%* 的用户通过 IPv6 访问 Google
- 中国、印度、美国的移动网络 IPv6 普及率 >50%
- 但许多企业网络、ISP 仍然只支持 IPv4

*双栈 (Dual Stack)*:

现代操作系统同时支持 IPv4 和 IPv6, 根据 DNS 返回的记录选择:

#+begin_src bash
$ dig google.com A AAAA
;; A 记录 (IPv4)
google.com.  300  IN  A  142.250.185.46

;; AAAA 记录 (IPv6)
google.com.  300  IN  AAAA  2404:6800:4003:c00::8a
#+end_src

*过渡技术*:

- *6to4, 6rd*: 在 IPv4 网络上隧道传输 IPv6
- *NAT64*: IPv6-only 网络访问 IPv4 服务

* ICMP: IP 的诊断助手

ICMP (Internet Control Message Protocol) 是网络层的 *控制协议*, 用于错误报告和网络诊断。

** 为什么需要 ICMP？

IP 协议本身是 "哑" 的, 它不会告诉你:

- 目标主机不可达
- 数据报被丢弃的原因
- 网络拥塞情况

ICMP 填补了这个空白, 提供 *网络层的反馈*。

** ICMP 的工作方式

当路由器或目标主机遇到问题时, 会向 *源主机* 发送 ICMP 消息:

#+begin_example
主机 A → 路由器 R → (发现问题)
                    → ICMP 消息回 A
#+end_example

*重要*: ICMP 消息本身也封装在 IP 数据报中 (Protocol=1), 所以它们也可能丢失。

** ICMPv4 头部结构

#+begin_example
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |     Type      |     Code      |          Checksum             |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                       Rest of Header                          |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                         (Optional Data)                       |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#+end_example

- *Type/Code*: 消息类型和子类型
- *Checksum*: 覆盖整个 ICMP 消息
- *Rest of Header*: 根据类型变化 (如 Echo 中包含 Identifier 和 Sequence Number)

** 常见 ICMP 消息类型

| Type | Code | 名称                    | 用途                         |
|------|------|-------------------------|------------------------------|
| 0    | 0    | Echo Reply              | =ping= 的应答                 |
| 3    | 0-15 | Destination Unreachable | 目标不可达 (网络/主机/端口...)  |
| 5    | 0-3  | Redirect                | 路由重定向                    |
| 8    | 0    | Echo Request            | =ping= 的请求                 |
| 11   | 0-1  | Time Exceeded           | TTL 超时 (=traceroute= 利用)   |
| 12   | 0-2  | Parameter Problem       | IP 头部参数错误               |

*** Echo Request/Reply (Ping)

=ping= 命令通过发送 *ICMP Echo Request* (Type=8) 来测试连通性:

#+begin_src bash
$ ping google.com
PING google.com (142.250.185.46): 56 data bytes
64 bytes from 142.250.185.46: icmp_seq=0 ttl=117 time=12.3 ms
64 bytes from 142.250.185.46: icmp_seq=1 ttl=117 time=11.8 ms
#+end_src

*流程*:

1. 发送 ICMP Echo Request, 包含 Identifier (进程 ID) 和 Sequence Number
2. 目标主机收到后, 原样返回 Echo Reply (Type=0)
3. 计算往返时间 (RTT)

*** Destination Unreachable

当路由器或目标主机无法转发数据报时, 发送此消息:

*常见 Code*:

- Code=0: Network Unreachable (无路由到达目标网络)
- Code=1: Host Unreachable (目标主机不在线)
- Code=3: Port Unreachable (目标端口未监听, UDP 常见)
- Code=4: Fragmentation Needed (需要分片但设置了 DF 标志)

*** Time Exceeded

*Code=0*: TTL 超时 (路由环路或路径太长)

=traceroute= 利用这个机制探测路径:

1. 发送 TTL=1 的 UDP 包 → 第一跳路由器返回 Time Exceeded
2. 发送 TTL=2 的 UDP 包 → 第二跳路由器返回 Time Exceeded
3. 直到到达目标主机 (返回 Port Unreachable, 因为 UDP 端口随机)

#+begin_src bash
$ traceroute google.com
 1  192.168.1.1 (192.168.1.1)  1.2 ms
 2  10.0.0.1 (10.0.0.1)  5.6 ms
 3  203.0.113.1 (203.0.113.1)  12.3 ms
 ...
#+end_src

** ICMPv6: 功能扩展

ICMPv6 (Protocol=58 in IPv6) 除了错误报告, 还承担了 *IPv6 的核心功能*:

*** Neighbor Discovery Protocol (NDP)

*取代 IPv4 的 ARP*:

- *Neighbor Solicitation* (Type=135): "谁有这个 IPv6 地址?"
- *Neighbor Advertisement* (Type=136): "我有, 我的 MAC 是 xx:xx:xx:xx:xx:xx"

*** Router Discovery

- *Router Solicitation* (Type=133): 主机询问 "谁是路由器?"
- *Router Advertisement* (Type=134): 路由器广播其存在和前缀信息

这允许 IPv6 主机 *自动配置* 地址 (SLAAC, Stateless Address Autoconfiguration)。

*** 其他改进

- *Packet Too Big* (Type=2): 取代 IPv4 的 Fragmentation Needed, 用于 PMTUD
- *Multicast Listener Discovery* (MLD): 取代 IGMP

** ICMP 的安全问题

*** 1. ICMP Flood (Ping Flood)

攻击者发送大量 Echo Request, 耗尽目标带宽/CPU。

*防御*: 限速 ICMP (Rate Limiting), 或在防火墙上丢弃外部 ICMP。

*** 2. ICMP Redirect 攻击

恶意路由器发送 Redirect 消息, 劫持流量。

*防御*: 现代系统默认忽略来自非网关的 Redirect。

*** 3. Smurf 攻击

伪造源 IP 为受害者, 向广播地址发送 Echo Request, 导致所有主机向受害者回复。

*防御*: 路由器禁止转发目标为广播地址的 ICMP。

* TCP: 可靠传输的基石

TCP (Transmission Control Protocol) 是传输层的 *可靠* 协议, 在不可靠的 IP 之上提供:

- *可靠性*: 保证数据按序、无丢失、无重复送达
- *流量控制*: 防止发送方淹没接收方
- *拥塞控制*: 防止网络过载

** TCP 头部结构

#+begin_example
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |          Source Port          |       Destination Port        |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                        Sequence Number                        |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                    Acknowledgment Number                      |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |  Data |           |U|A|P|R|S|F|                               |
 | Offset| Reserved  |R|C|S|S|Y|I|       Window Size             |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |         Checksum              |       Urgent Pointer          |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                    Options (if any)                           |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#+end_example

*关键字段*:

- *Sequence Number*: 本段数据的第一个字节在整个流中的序号
- *Acknowledgment Number*: 期望接收的下一个字节序号 (累积确认)
- *Flags*:
  - =SYN= (Synchronize): 建立连接
  - =ACK= (Acknowledgment): 确认号有效
  - =FIN= (Finish): 关闭连接
  - =RST= (Reset): 强制中止连接
  - =PSH= (Push): 立即推送数据到应用层
  - =URG= (Urgent): 紧急指针有效
- *Window Size*: 接收窗口大小 (流量控制)
- *Checksum*: 覆盖伪头部 (源/目的 IP) + TCP 头部 + 数据

** TCP 连接管理: 三次握手与四次挥手

*** 三次握手 (Three-Way Handshake)

#+begin_example
客户端                                服务器
   |                                    |
   |-- SYN (seq=100) ------------------>|  (1) 客户端请求连接
   |                                    |
   |<-- SYN-ACK (seq=300, ack=101) -----|  (2) 服务器确认并请求连接
   |                                    |
   |-- ACK (seq=101, ack=301) --------->|  (3) 客户端确认
   |                                    |
   |========== 连接建立 ================|
#+end_example

*为什么需要三次？*

- *两次不够*: 防止旧的重复 SYN 包建立幽灵连接
- *四次多余*: 第二步可以合并 SYN 和 ACK

*初始序列号 (ISN)*:

每次连接的初始 Sequence Number 是 *随机* 的 (基于时钟或随机数), 防止:

- 旧连接的数据包污染新连接
- TCP 序列号预测攻击

*** 四次挥手 (Four-Way Handshake)

#+begin_example
客户端                                服务器
   |                                    |
   |-- FIN (seq=500) ------------------>|  (1) 客户端关闭发送
   |                                    |
   |<-- ACK (ack=501) ------------------|  (2) 服务器确认
   |                                    |
   |    (服务器可能继续发送数据)           |
   |                                    |
   |<-- FIN (seq=800) ------------------|  (3) 服务器关闭发送
   |                                    |
   |-- ACK (ack=801) ------------------>|  (4) 客户端确认
   |                                    |
   |========== 连接关闭 ================|
#+end_example

*为什么需要四次？*

TCP 是 *全双工* 的, 每个方向需要独立关闭:

- FIN 只关闭 *发送* 方向
- 对方仍可继续发送数据 (半关闭状态)

*TIME_WAIT 状态*:

主动关闭方在发送最后的 ACK 后, 会进入 =TIME_WAIT= 状态 (通常 2 * MSL, 约 60 秒):

- 确保最后的 ACK 到达 (如果丢失, 对方会重传 FIN)
- 防止旧连接的延迟数据包污染新连接

*快速关闭: RST*

如果一方想 *立即* 中止连接 (不等待对方), 可以发送 =RST= 包:

#+begin_src c
close(sockfd);           // 正常四次挥手
shutdown(sockfd, SHUT_RDWR);  // 优雅关闭

// 强制 RST
struct linger linger = {1, 0};
setsockopt(sockfd, SOL_SOCKET, SO_LINGER, &linger, sizeof(linger));
close(sockfd);
#+end_src

** TCP 状态机

TCP 连接的完整状态转换图:

#+begin_example
         客户端                           服务器
           |                                |
    [CLOSED]                           [CLOSED]
           |                                |
    主动打开 (SYN)                       被动打开 (listen)
           ↓                                ↓
      [SYN_SENT] ----------------------> [LISTEN]
           |                                |
           |  (收到 SYN-ACK)         (收到 SYN) ↓
           ↓                           [SYN_RCVD]
    [ESTABLISHED] <-------------------- (发送 SYN-ACK)
           ↓                                ↓
    主动关闭 (FIN)                    [ESTABLISHED]
           ↓                                |
      [FIN_WAIT_1]                   (收到 FIN) ↓
           |                           [CLOSE_WAIT]
    (收到 ACK) ↓                             |
      [FIN_WAIT_2]                    被动关闭 (FIN)
           |                                ↓
    (收到 FIN) ↓                        [LAST_ACK]
      [TIME_WAIT] <------------------- (收到 ACK)
           |                                ↓
    (2MSL 超时)                         [CLOSED]
           ↓
       [CLOSED]
#+end_example

*关键状态*:

- =LISTEN=: 服务器等待连接
- =SYN_SENT/SYN_RCVD=: 握手中
- =ESTABLISHED=: 连接已建立
- =FIN_WAIT_1/FIN_WAIT_2=: 主动关闭, 等待对方 FIN
- =CLOSE_WAIT=: 被动关闭, 等待应用层调用 =close()=
- =TIME_WAIT=: 等待旧数据包消失

*常见问题*:

- 大量 =TIME_WAIT=: 高频短连接导致 (HTTP/1.0)
  - 解决: 用 HTTP/1.1 的 Keep-Alive, 或调大端口范围
- =CLOSE_WAIT= 不消失: 应用层未正确调用 =close()=
  - 解决: 修复代码逻辑

** TCP 可靠性机制

*** 1. 累积确认 (Cumulative ACK)

ACK 号表示 "我已收到所有 < ACK 的字节":

#+begin_example
发送: [1-100], [101-200], [201-300]
接收: [1-100] → ACK=101
      [101-200] → ACK=201
      (201-300 丢失)
      [301-400] → ACK=201 (仍然是 201, 因为 201-300 缺失)
#+end_example

*** 2. 重传机制

*超时重传 (RTO, Retransmission Timeout)*:

如果发送数据后, 在 RTO 时间内未收到 ACK, 则重传。

RTO 动态计算 (基于 RTT):

#+begin_example
SRTT (平滑 RTT) = 0.875 * SRTT + 0.125 * RTT
RTTVAR (方差) = 0.75 * RTTVAR + 0.25 * |SRTT - RTT|
RTO = SRTT + 4 * RTTVAR
#+end_example

*快速重传 (Fast Retransmit)*:

如果收到 *3 个重复 ACK*, 立即重传 (不等 RTO):

#+begin_example
接收: [1-100] → ACK=101
      [101-200] (丢失)
      [201-300] → ACK=101 (重复 ACK #1)
      [301-400] → ACK=101 (重复 ACK #2)
      [401-500] → ACK=101 (重复 ACK #3, 触发快速重传)
#+end_example

*** 3. 选择性确认 (SACK, Selective Acknowledgment)

累积 ACK 的问题: 一个包丢失, 后面的包即使收到也要等。

SACK 允许接收方告诉发送方 "我收到了 201-300 和 401-500, 但缺 101-200":

#+begin_example
TCP Option: SACK Permitted (握手时协商)
TCP Option: SACK (数据传输中)
  - Left Edge: 201
  - Right Edge: 301
  - Left Edge: 401
  - Right Edge: 501
#+end_example

发送方只重传 101-200, 而不是 101-500。

** TCP 流量控制: 滑动窗口

*目标*: 防止发送方发送速度 > 接收方处理速度。

*机制*: 接收方在 ACK 中告知 *接收窗口大小* (Window Size):

#+begin_example
接收方缓冲区: 10000 字节
已接收未读: 3000 字节
剩余空间: 7000 字节 → Window=7000
#+end_example

发送方最多只能发送 =min(拥塞窗口, 接收窗口)= 的数据。

*零窗口问题*:

如果接收方缓冲区满 (Window=0), 发送方停止发送。为防止死锁, 发送方定期发送 *窗口探测* (Zero Window Probe)。

** TCP 拥塞控制: 防止网络崩溃

*目标*: 防止发送方发送速度 > 网络容量, 导致路由器丢包。

*核心变量*:

- *cwnd* (Congestion Window): 拥塞窗口, 发送方维护
- *ssthresh* (Slow Start Threshold): 慢启动阈值

*** 1. 慢启动 (Slow Start)

连接开始时, =cwnd= 从 1 MSS (Maximum Segment Size, 通常 1460 字节) 开始, 每收到一个 ACK *翻倍*:

#+begin_example
RTT 0: cwnd=1, 发送 1 个包
RTT 1: cwnd=2, 发送 2 个包
RTT 2: cwnd=4, 发送 4 个包
RTT 3: cwnd=8, 发送 8 个包
...
#+end_example

当 =cwnd >= ssthresh= 时, 进入拥塞避免。

*** 2. 拥塞避免 (Congestion Avoidance)

每个 RTT, =cwnd= 只增加 1 MSS (线性增长):

#+begin_example
cwnd += MSS * (MSS / cwnd)
#+end_example

*** 3. 快速恢复 (Fast Recovery)

收到 3 个重复 ACK 时:

1. =ssthresh = cwnd / 2=
2. =cwnd = ssthresh + 3 MSS=
3. 重传丢失的包
4. 每收到一个重复 ACK, =cwnd += 1 MSS= (Inflate)
5. 收到新 ACK 后, =cwnd = ssthresh= (Deflate)

*** 现代算法

- *TCP Reno*: 经典算法 (慢启动 + 拥塞避免 + 快速重传/恢复)
- *TCP Cubic*: Linux 默认, 适合高带宽长延迟网络
- *TCP BBR*: Google 开发, 基于带宽和 RTT 的主动控制 (不等丢包)

** TCP 选项 (Options)

TCP 头部可以携带可选字段 (最多 40 字节):

*** MSS (Maximum Segment Size)

*握手时协商*, 告知对方 "我最多能接收多大的段":

#+begin_example
TCP Option: MSS=1460
#+end_example

通常是 MTU - IP 头 (20) - TCP 头 (20) = 1460。

*** Window Scaling

Window Size 字段只有 16 位, 最大 65535 字节。对于高带宽网络 (如 10 Gbps), 这太小了。

*Window Scaling* 允许将窗口 *左移* N 位:

#+begin_example
TCP Option: Window Scale=7
实际窗口 = Window Size << 7 = 65535 << 7 = 8MB
#+end_example

*握手时协商*, 之后生效。

*** Timestamps

用于:

- *RTT 测量*: 不需要为每个包设置定时器
- *PAWS* (Protection Against Wrapped Sequences): 防止序列号回绕时的混乱

#+begin_example
TCP Option: Timestamp=12345678, Echo Reply=12345600
#+end_example

*** SACK Permitted / SACK

见前文 "选择性确认"。

** TCP 安全问题

*** 1. SYN Flood 攻击

攻击者发送大量 SYN 包 (伪造源 IP), 服务器分配资源等待 ACK, 导致 *半连接队列* 耗尽。

*防御*:

- *SYN Cookies*: 不分配资源, 将状态编码在 ISN 中
- *增大半连接队列*: =net.ipv4.tcp_max_syn_backlog=
- *缩短超时*: =net.ipv4.tcp_synack_retries=

*** 2. TCP RST 攻击

攻击者伪造 RST 包, 中断合法连接。

*防御*:

- 检查序列号是否在窗口内 (RFC 5961)
- 使用 TLS (加密后无法伪造)

*** 3. TCP 序列号预测

早期 TCP 的 ISN 是可预测的 (基于时钟), 攻击者可伪造数据包。

*防御*:

- 现代系统使用强随机数生成 ISN (RFC 6528)

* UDP: 简单但危险的自由

UDP (User Datagram Protocol) 是传输层的 *无连接* 协议, 在 IP 之上只做了 *最小封装*。

** UDP 头部结构

#+begin_example
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |          Source Port          |       Destination Port        |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |            Length             |           Checksum            |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                             Data ...                          |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#+end_example

*仅 8 字节头部*:

- *Source/Destination Port*: 16 位端口号
- *Length*: UDP 头部 + 数据的总长度 (最小 8, 最大 65535)
- *Checksum*: 可选 (IPv4 可为 0, IPv6 必须)

** UDP 的 "三无" 特性

*** 1. 无连接

直接发送, 不需要握手:

#+begin_src c
int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
sendto(sockfd, data, len, 0, &dest_addr, sizeof(dest_addr));
#+end_src

*** 2. 无可靠性

- 数据报可能丢失
- 数据报可能重复
- 数据报可能乱序

*应用层* 需要自己处理这些问题 (如 QUIC, DNS)。

*** 3. 无流量/拥塞控制

发送方可以以 *任意速率* 发送数据, 可能导致:

- 接收方缓冲区溢出
- 网络拥塞

** UDP 的适用场景

*** 1. 低延迟应用

- *实时音视频* (RTP/RTCP): 宁可丢帧, 也不能卡顿
- *在线游戏*: 位置更新丢失无所谓, 下一帧会刷新
- *VoIP*: 丢失几个音频包影响小

*** 2. 简单请求/响应

- *DNS*: 单个查询/响应, UDP 头部小 (8 字节 vs TCP 20 字节 + 握手)
- *DHCP*: 获取 IP 地址
- *NTP*: 时间同步

*** 3. 广播/组播

TCP 不支持广播/组播, UDP 可以:

#+begin_src c
// 发送到广播地址
struct sockaddr_in broadcast_addr;
broadcast_addr.sin_addr.s_addr = inet_addr("255.255.255.255");
sendto(sockfd, data, len, 0, ...);
#+end_src

** UDP 的安全问题

*** 1. UDP Flood

攻击者发送大量 UDP 包, 耗尽带宽或 CPU。

*防御*:

- 限速 (Rate Limiting)
- 使用 Conntrack 过滤无状态包

*** 2. UDP 放大攻击

利用某些 UDP 服务的 *响应 > 请求* 特性, 放大攻击流量:

#+begin_example
攻击者 → DNS 服务器 (伪造源 IP=受害者)
查询: "ANY example.com" (60 字节)
响应: 3000 字节 → 受害者

放大倍数: 50x
#+end_example

*常见放大服务*:

- DNS (ANY 查询)
- NTP (monlist 命令)
- SNMP (GetBulk)
- memcached (stats 命令)

*防御*:

- 禁用放大命令 (如 NTP 的 monlist)
- 限制响应大小
- BCP 38 (ISP 过滤伪造源 IP)

* DNS: 互联网的电话簿

DNS (Domain Name System) 将人类可读的域名 (如 =google.com=) 转换为 IP 地址 (如 =142.250.185.46=)。

** DNS 查询流程

#+begin_example
用户输入: google.com
  ↓
1. 查询本地缓存 (浏览器/OS)
  ↓ (未命中)
2. 查询递归解析器 (ISP 或 8.8.8.8)
  ↓
3. 递归解析器查询根服务器 (.): "谁负责 .com?"
  ↓
4. 根服务器返回 .com 的 TLD 服务器
  ↓
5. 查询 .com TLD 服务器: "谁负责 google.com?"
  ↓
6. TLD 服务器返回 google.com 的权威服务器
  ↓
7. 查询 google.com 权威服务器: "google.com 的 A 记录?"
  ↓
8. 返回 IP: 142.250.185.46
  ↓
9. 缓存结果 (TTL 300 秒)
#+end_example

** DNS 记录类型

| 类型    | 用途                     | 示例                                   |
|--------|-------------------------|----------------------------------------|
| A      | 域名 → IPv4              | =google.com → 142.250.185.46=            |
| AAAA   | 域名 → IPv6              | =google.com → 2404:6800:4003:c00::8a=    |
| CNAME  | 别名                     | =www.example.com → example.com=          |
| MX     | 邮件服务器                | =example.com → mail.example.com=         |
| NS     | 域名服务器                | =example.com → ns1.example.com=          |
| TXT    | 文本记录 (SPF, DKIM)     | ="v=spf1 include:_spf.google.com ~all"= |
| PTR    | 反向解析 (IP → 域名)      | =46.185.250.142.in-addr.arpa → google.com= |

** DNS 劫持 (DNS Hijacking / Poisoning)

攻击者通过以下方式返回虚假 IP:

*** 1. DNS 缓存投毒 (Cache Poisoning)

攻击者伪造 DNS 响应, 污染递归解析器的缓存:

#+begin_example
用户 → 递归解析器: "google.com?"
攻击者 → 递归解析器: "google.com = 203.0.113.66" (伪造响应, 更早到达)
权威服务器 → 递归解析器: "google.com = 142.250.185.46" (真实响应, 被忽略)
#+end_example

*防御*:

- *DNSSEC*: 数字签名验证响应真实性
- *源端口随机化*: 使伪造响应难以猜测目标端口
- *Query ID 随机化*

*** 2. 中间人攻击 (MITM)

ISP 或网络设备拦截 DNS 查询, 返回虚假响应。

*防御*:

- *DNS over HTTPS (DoH)*: 加密 DNS 查询 (Firefox/Chrome 支持)
- *DNS over TLS (DoT)*: 端口 853
- *DNSCrypt*

*** 3. 本地 hosts 文件篡改

恶意软件修改 =C:\Windows\System32\drivers\etc\hosts= (Windows) 或 =/etc/hosts= (Linux):

#+begin_example
203.0.113.66  google.com
#+end_example

*防御*:

- 文件权限保护
- 安全软件监控

** DNS 隐私问题

传统 DNS 查询是 *明文* 的, ISP 可以看到你访问的所有域名。

*解决方案*:

- *DoH/DoT*: 加密查询
- *Oblivious DNS (ODoH)*: 隐藏查询者身份

* ARP: 从 IP 到 MAC 的翻译

ARP (Address Resolution Protocol) 在 *链路层* 工作, 将网络层的 IP 地址翻译为链路层的 MAC 地址。

** 为什么需要 ARP？

以太网帧使用 *MAC 地址* 寻址, 而上层使用 *IP 地址*。当主机要发送 IP 数据报到同一局域网的另一主机时, 需要知道对方的 MAC 地址。

** ARP 头部结构

#+begin_example
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |           HTYPE (ar$hrd)      |           PTYPE (ar$pro)      |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |  HLEN (ar$hln) |  PLEN (ar$pln)|           OPER (ar$op)       |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               |
 ~            SHA: Sender Hardware Address (HLEN bytes)          ~
 |                                                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               |
 ~            SPA: Sender Protocol Address (PLEN bytes)          ~
 |                                                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               |
 ~            THA: Target Hardware Address (HLEN bytes)          ~
 |                                                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               |
 ~            TPA: Target Protocol Address (PLEN bytes)          ~
 |                                                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#+end_example

*字段说明*:

- *HTYPE*: 硬件类型 (Ethernet=1)
- *PTYPE*: 协议类型 (IPv4=0x0800)
- *HLEN*: 硬件地址长度 (MAC=6)
- *PLEN*: 协议地址长度 (IPv4=4)
- *OPER*: 操作码 (Request=1, Reply=2)
- *SHA/SPA*: 发送方的 MAC/IP
- *THA/TPA*: 目标的 MAC/IP (Request 中 THA 未知)

** ARP 工作流程

*** 场景: 主机 A (192.168.1.10) 要发送数据到主机 B (192.168.1.20)

1. *A 检查 ARP 缓存*:

#+begin_src bash
$ arp -a
? (192.168.1.1) at aa:bb:cc:dd:ee:ff on en0 ifscope [ethernet]
# 没有 192.168.1.20 的记录
#+end_src

2. *A 广播 ARP Request*:

#+begin_example
以太网帧:
  Dest MAC: ff:ff:ff:ff:ff:ff (广播)
  Src MAC: 00:11:22:33:44:55 (A 的 MAC)

ARP 消息:
  OPER: Request (1)
  SHA: 00:11:22:33:44:55 (A 的 MAC)
  SPA: 192.168.1.10 (A 的 IP)
  THA: 00:00:00:00:00:00 (未知)
  TPA: 192.168.1.20 (B 的 IP)

语义: "谁有 192.168.1.20? 请告诉 192.168.1.10 (MAC 00:11:22:33:44:55)"
#+end_example

3. *B 收到 ARP Request, 单播回复*:

#+begin_example
以太网帧:
  Dest MAC: 00:11:22:33:44:55 (A 的 MAC)
  Src MAC: aa:bb:cc:dd:ee:ff (B 的 MAC)

ARP 消息:
  OPER: Reply (2)
  SHA: aa:bb:cc:dd:ee:ff (B 的 MAC)
  SPA: 192.168.1.20 (B 的 IP)
  THA: 00:11:22:33:44:55 (A 的 MAC)
  TPA: 192.168.1.10 (A 的 IP)

语义: "我是 192.168.1.20, 我的 MAC 是 aa:bb:cc:dd:ee:ff"
#+end_example

4. *A 缓存 B 的 MAC 地址*:

#+begin_src bash
$ arp -a
? (192.168.1.20) at aa:bb:cc:dd:ee:ff on en0 ifscope [ethernet]
#+end_src

5. *A 发送 IP 数据报*:

#+begin_example
以太网帧:
  Dest MAC: aa:bb:cc:dd:ee:ff
  Src MAC: 00:11:22:33:44:55
  Type: 0x0800 (IPv4)

IP 数据报:
  Dest IP: 192.168.1.20
  Src IP: 192.168.1.10
  ...
#+end_example

** ARP 缓存老化

ARP 缓存条目有 *生存时间* (通常 60-300 秒), 超时后自动删除, 需要重新查询。

#+begin_src bash
# Linux 查看/修改 ARP 缓存
ip neigh show
ip neigh flush all

# macOS
arp -a
sudo arp -d 192.168.1.20  # 删除特定条目
#+end_src

** Gratuitous ARP (免费 ARP)

主机主动发送 ARP Request/Reply, 目标 IP 是 *自己的 IP*:

*用途*:

1. *检测 IP 冲突*: 如果有人回复, 说明 IP 重复
2. *更新邻居缓存*: 主机 IP/MAC 变化时, 通知其他主机
3. *VRRP/HA*: 虚拟 IP 切换时, 新主机声明接管

** ARP 欺骗 (ARP Spoofing)

攻击者伪造 ARP Reply, 将自己的 MAC 地址绑定到受害者的 IP:

#+begin_example
攻击者 → 网关: "192.168.1.100 的 MAC 是 攻击者MAC" (伪造)
网关缓存: 192.168.1.100 → 攻击者MAC

发往 192.168.1.100 的流量 → 攻击者 (中间人攻击)
#+end_example

*防御*:

- *静态 ARP 绑定*: 手动绑定关键主机的 IP-MAC
- *DAI* (Dynamic ARP Inspection): 交换机验证 ARP 合法性
- *ARP 监控工具*: arpwatch, XArp

* TLS/SSL: 为 TCP 加密

TLS (Transport Layer Security) 和其前身 SSL (Secure Sockets Layer) 是 *应用层* 的加密协议, 为 TCP 连接提供:

- *加密* (Confidentiality): 防止窃听
- *完整性* (Integrity): 防止篡改
- *认证* (Authentication): 确认服务器身份

** TLS 握手流程 (简化版)

#+begin_example
客户端                                      服务器
   |                                         |
   |-- ClientHello ------------------------->|  (1) 支持的协议版本、加密套件
   |                                         |
   |<-- ServerHello -------------------------|  (2) 选择的协议版本、加密套件
   |<-- Certificate -------------------------|  (3) 服务器证书 (包含公钥)
   |<-- ServerHelloDone ---------------------|
   |                                         |
   |-- ClientKeyExchange ------------------->|  (4) 用服务器公钥加密的 PreMasterSecret
   |-- ChangeCipherSpec -------------------->|  (5) 切换到加密通信
   |-- Finished (encrypted) ---------------->|  (6) 握手完成
   |                                         |
   |<-- ChangeCipherSpec --------------------|
   |<-- Finished (encrypted) ----------------|
   |                                         |
   |========== 加密数据传输 ===================|
#+end_example

** 关键概念

*** 1. 证书链 (Certificate Chain)

服务器证书由 *CA* (Certificate Authority) 签发, 形成信任链:

#+begin_example
根 CA (VeriSign) → 中间 CA (DigiCert) → 服务器证书 (google.com)
#+end_example

客户端验证:

1. 检查证书签名 (用 CA 公钥验证)
2. 检查证书有效期
3. 检查域名是否匹配 (CN 或 SAN)
4. 检查证书吊销状态 (CRL/OCSP)

*** 2. 加密套件 (Cipher Suite)

定义了加密算法组合:

#+begin_example
TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256

分解:
  - ECDHE: 密钥交换算法 (椭圆曲线 Diffie-Hellman)
  - RSA: 身份验证算法
  - AES_128_GCM: 对称加密算法 (128 位 AES, GCM 模式)
  - SHA256: 消息认证码 (MAC) 算法
#+end_example

*现代推荐*:

- =TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384=
- =TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256=

*禁用*:

- RC4, DES, 3DES (已破解或过时)
- MD5, SHA1 (哈希碰撞风险)

*** 3. 前向保密 (Forward Secrecy)

如果服务器私钥泄露, *过去* 的会话密钥是否会被破解？

- *RSA 密钥交换*: 会 (私钥可解密所有 PreMasterSecret)
- *ECDHE/DHE*: 不会 (每次会话生成临时密钥对)

*推荐使用 ECDHE。*

** TLS 1.3 的改进

*** 1. 简化握手 (0-RTT)

传统 TLS 1.2 需要 2 个往返 (2-RTT):

#+begin_example
RTT 1: ClientHello → ServerHello
RTT 2: KeyExchange → Finished
RTT 3: 应用数据
#+end_example

TLS 1.3 只需 1-RTT:

#+begin_example
RTT 1: ClientHello (含密钥) → ServerHello + 应用数据
#+end_example

甚至支持 0-RTT (复用之前的会话密钥), 但有重放攻击风险。

*** 2. 移除弱加密套件

TLS 1.3 *强制* 使用:

- AEAD 加密 (AES-GCM, ChaCha20-Poly1305)
- ECDHE 密钥交换
- 禁止 RSA 密钥交换、CBC 模式、MD5/SHA1

*** 3. 加密握手

除了 ClientHello/ServerHello, *所有* 握手消息都加密, 防止中间人窥探:

- 证书
- 扩展信息
- 会话票据

** HTTPS = HTTP + TLS

HTTPS 在 TCP 443 端口上运行, 流程:

#+begin_example
1. TCP 三次握手 (端口 443)
2. TLS 握手
3. HTTP 请求/响应 (加密传输)
#+end_example

*常见错误*:

- *证书不匹配*: 访问 =https://192.168.1.1=, 但证书是 =example.com=
- *自签名证书*: 浏览器不信任 (需手动添加到信任列表)
- *中间人攻击*: 公共 WiFi 上的 SSL 剥离攻击

** Let's Encrypt: 免费证书

Let's Encrypt 是非营利 CA, 提供 *免费* 的 DV (Domain Validation) 证书:

#+begin_src bash
# 安装 certbot
sudo apt install certbot

# 自动获取证书并配置 Nginx
sudo certbot --nginx -d example.com -d www.example.com

# 自动续期 (证书 90 天有效期)
sudo certbot renew
#+end_src

*工作原理* (ACME 协议):

1. 客户端向 Let's Encrypt 请求证书
2. Let's Encrypt 返回挑战 (在 =http://example.com/.well-known/acme-challenge/= 放置特定文件)
3. 客户端完成挑战
4. Let's Encrypt 验证后签发证书

* WebSocket: 全双工的 Web 通信

WebSocket 是 *应用层* 协议, 在 HTTP 握手后 *升级* 为持久连接, 支持双向实时通信。

** 为什么需要 WebSocket？

传统 HTTP 是 *请求-响应* 模型:

- 客户端必须主动发起请求
- 服务器无法主动推送数据
- 每次请求都有 HTTP 头部开销 (几百字节)

*Workaround*:

- *轮询* (Polling): 客户端定期发送请求 (浪费带宽)
- *长轮询* (Long Polling): 服务器延迟响应直到有数据 (复杂)
- *SSE* (Server-Sent Events): 单向推送, 无法客户端→服务器

*WebSocket 解决方案*:

- 一次握手, 持久连接
- 双向通信 (服务器可主动推送)
- 低开销 (每条消息只有 2-14 字节头部)

** WebSocket 握手

WebSocket 复用 HTTP 的 80/443 端口, 通过 HTTP *Upgrade* 握手:

*** 客户端请求

#+begin_example
GET /chat HTTP/1.1
Host: example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13
#+end_example

*关键字段*:

- =Upgrade: websocket=: 请求协议升级
- =Sec-WebSocket-Key=: 随机 Base64 编码的 16 字节 nonce
- =Sec-WebSocket-Version=: 协议版本 (通常是 13)

*** 服务器响应

#+begin_example
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
#+end_example

*关键字段*:

- =101 Switching Protocols=: 同意升级
- =Sec-WebSocket-Accept=: 根据客户端 Key 计算:

#+begin_src python
import hashlib
import base64

key = "dGhlIHNhbXBsZSBub25jZQ=="
magic = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"  # RFC 6455 规定
sha1 = hashlib.sha1((key + magic).encode()).digest()
accept = base64.b64encode(sha1).decode()
# 输出: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
#+end_src

*** 升级后

TCP 连接变为 *WebSocket 连接*, 不再使用 HTTP 格式, 而是 WebSocket 帧格式。

** WebSocket 帧格式

#+begin_example
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-------+-+-------------+-------------------------------+
 |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
 |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
 |N|V|V|V|       |S|             |   (if payload len==126/127)   |
 | |1|2|3|       |K|             |                               |
 +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
 |     Extended payload length continued, if payload len == 127  |
 + - - - - - - - - - - - - - - - +-------------------------------+
 |                               | Masking-key, if MASK set to 1 |
 +-------------------------------+-------------------------------+
 | Masking-key (continued)       |          Payload Data         |
 +-------------------------------- - - - - - - - - - - - - - - - +
 :                     Payload Data continued ...                :
 + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
 |                     Payload Data continued ...                |
 +---------------------------------------------------------------+
#+end_example

*关键字段*:

- *FIN*: 是否是最后一帧 (分片传输)
- *Opcode*:
  - =0x1=: 文本帧
  - =0x2=: 二进制帧
  - =0x8=: 关闭连接
  - =0x9/0xA=: Ping/Pong (心跳)
- *MASK*: 客户端→服务器的帧 *必须* 掩码 (防止缓存投毒攻击)
- *Payload Length*: 数据长度 (7 位、16 位或 64 位)

** WebSocket 应用场景

*** 1. 实时聊天

#+begin_src javascript
const ws = new WebSocket('wss://chat.example.com');

ws.onopen = () => {
  ws.send('Hello, server!');
};

ws.onmessage = (event) => {
  console.log('Received:', event.data);
};

ws.onerror = (error) => {
  console.error('Error:', error);
};
#+end_src

*** 2. 实时协作 (如 Google Docs)

多个用户同时编辑文档, 通过 WebSocket 同步修改。

*** 3. 游戏多人对战

低延迟的位置同步。

*** 4. 金融行情推送

实时股票价格、加密货币交易数据。

** WebSocket vs HTTP/2 Server Push

HTTP/2 也支持服务器推送, 但它是 *单向* 的:

- 客户端请求 =index.html=
- 服务器推送 =style.css=, =script.js=

WebSocket 是 *双向* 的, 适合需要客户端频繁发送数据的场景。

** WebSocket 安全

*** 1. 使用 WSS (WebSocket over TLS)

#+begin_src javascript
const ws = new WebSocket('wss://example.com');  // 加密
// 而不是 ws://example.com (明文)
#+end_src

*** 2. 验证 Origin

服务器应检查 =Origin= 头, 防止 CSRF:

#+begin_src python
# Python (Flask-SocketIO)
@socketio.on('connect')
def handle_connect():
    origin = request.headers.get('Origin')
    if origin not in ALLOWED_ORIGINS:
        return False  # 拒绝连接
#+end_src

*** 3. 限速和认证

- 限制每个连接的消息频率
- 在握手时传递认证 token

#+begin_src javascript
const ws = new WebSocket('wss://example.com?token=abc123');
#+end_src

* 分组交换与延迟分析

Internet 使用 *分组交换* (Packet Switching), 而非电路交换 (Circuit Switching)。

** 端到端延迟的组成

一个数据包从源到目的地的总延迟:

#+begin_example
总延迟 = 传播延迟 + 分组延迟 + 排队延迟 + 处理延迟
#+end_example

*** 1. 传播延迟 (Propagation Delay)

信号在介质中传播的时间:

$d_{prop} = \frac{距离}{传播速度}$

*示例*:

- 光纤: $v \approx 2 \times 10^8$ m/s (光速的 2/3)
- 铜线: $v \approx 2.3 \times 10^8$ m/s
- 无线: $v = 3 \times 10^8$ m/s (光速)

#+begin_example
北京 → 旧金山 (10,000 km 光纤)
d_prop = 10,000,000 m / (2×10^8 m/s) = 50 ms
#+end_example

*这是物理极限, 无法减少。*

*** 2. 传输延迟 (Transmission Delay / Packetization Delay)

将数据包 "推入" 链路所需的时间:

$d_{trans} = \frac{数据包大小 (bits)}{链路带宽 (bps)}$

*示例*:

#+begin_example
1500 字节数据包, 1 Gbps 链路
d_trans = (1500 × 8) / (10^9) = 12 μs
#+end_example

*** 3. 排队延迟 (Queueing Delay)

数据包在路由器队列中等待的时间 (最不确定的部分):

- 队列空: $d_{queue} = 0$
- 队列满: 数据包被丢弃
- 队列中等: $d_{queue}$ 取决于流量负载

*流量强度* (Traffic Intensity):

$\rho = \frac{\lambda \times L}{R}$

其中:
- $\lambda$: 数据包到达率 (packets/sec)
- $L$: 平均数据包大小 (bits)
- $R$: 链路带宽 (bps)

*规律*:

- $\rho < 0.7$: 排队延迟小 (几乎无等待)
- $0.7 < \rho < 1$: 排队延迟快速增长
- $\rho \geq 1$: 队列无限增长 (崩溃)

*** 4. 处理延迟 (Processing Delay)

路由器检查头部、查找转发表、错误检测的时间:

- 现代高速路由器: 几微秒
- 软件路由器: 几十微秒

** 示例计算

*场景*: 发送 1 MB 文件, 分成 1000 个 1000 字节的包, 经过 3 个路由器, 到达目的地。

*参数*:

- 链路带宽: $R = 10$ Mbps
- 传播延迟: $d_{prop} = 5$ ms (每段)
- 处理延迟: $d_{proc} = 1$ μs
- 排队延迟: 忽略 (轻负载)

*计算*:

#+begin_example
单个包的传输延迟:
d_trans = (1000 × 8) / (10 × 10^6) = 0.8 ms

第一个包到达目的地:
t_1 = 3 × (d_prop + d_trans + d_proc)
    = 3 × (5 + 0.8 + 0.001) ms
    ≈ 17.4 ms

最后一个包到达目的地:
t_last = t_1 + 999 × d_trans
       = 17.4 + 999 × 0.8
       ≈ 817 ms
#+end_example

** 优化策略

*** 1. 增大带宽 → 减少传输延迟

10 Mbps → 100 Mbps: $d_{trans}$ 减少 10 倍

*** 2. 减少 RTT → 减少传播延迟

使用 CDN (Content Delivery Network), 将服务器放在离用户更近的位置。

*** 3. 流水线传输 → 并行化

不等第一个包到达, 就开始发送第二个包 (TCP 的滑动窗口)。

*** 4. 拥塞控制 → 减少排队延迟

避免 $\rho$ 接近 1。

** 结语

*这份笔记涵盖了从物理层到应用层的核心协议, 但网络是一个永远在演进的领域。*

新协议不断出现:

- *QUIC*: Google 开发的基于 UDP 的传输层协议, 已成为 HTTP/3 的基础
- *mTLS*: 双向 TLS 认证
- *WireGuard*: 现代 VPN 协议

*建议*:

- 实践: 用 Wireshark 抓包分析真实流量
- 深入: 阅读 RFC 文档 (虽然枯燥, 但权威)
- 关注: IETF, ACM SIGCOMM 的最新研究

*Network protocols are not just rules—they're the language that billions of devices speak to make the Internet work.*
