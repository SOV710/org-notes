#+title: Operating System Fundamentals: Synchronization, Processes, and the Unix Philosophy
#+author: SOV710
#+date: 2025-12-23
#+startup: showall
#+options: toc:2 num:nil

* 线程同步: 为什么需要互斥

** 问题的根源: 共享地址空间

由于线程能对同一个地址空间进行修改，多个线程可能同时访问同一块内存，导致 *竞态条件* (race condition)。

考虑一个简单的计数器:

#+begin_src c
int counter = 0;

void* increment(void* arg) {
    for (int i = 0; i < 1000000; i++) {
        counter++;  // 这不是原子操作！
    }
    return NULL;
}
#+end_src

如果两个线程同时运行 =increment()=，最终 =counter= 的值可能是 *任何小于等于 2,000,000 的数*，而不是预期的 2,000,000。

** 为什么 =counter++= 不是原子的？

在 x86 汇编层面，=counter++= 至少需要 3 条指令:

#+begin_src asm
mov  eax, [counter]   ; 1. 从内存读取 counter 到寄存器
add  eax, 1           ; 2. 寄存器 +1
mov  [counter], eax   ; 3. 写回内存
#+end_src

如果两个线程交错执行:

#+begin_example
时间  |  线程 A              |  线程 B              | counter 值
------|---------------------|---------------------|----------
  t0  | mov eax, [counter]  |                     | 0
      | (eax = 0)           |                     |
  t1  |                     | mov ebx, [counter]  | 0
      |                     | (ebx = 0)           |
  t2  | add eax, 1          |                     | 0
      | (eax = 1)           |                     |
  t3  |                     | add ebx, 1          | 0
      |                     | (ebx = 1)           |
  t4  | mov [counter], eax  |                     | 1
  t5  |                     | mov [counter], ebx  | 1  ← 丢失了一次更新！
#+end_example

最终 =counter= 是 1，而不是 2！这就是 *数据竞争* (data race)。

** 互斥: 临界区保护

*互斥* (mutual exclusion) 确保特定事件只有一个线程执行特定操作。被互斥排除的代码片段被称为 *临界区* (critical section)。

#+begin_src c
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
int counter = 0;

void* safe_increment(void* arg) {
    for (int i = 0; i < 1000000; i++) {
        pthread_mutex_lock(&lock);    // 进入临界区
        counter++;
        pthread_mutex_unlock(&lock);  // 离开临界区
    }
    return NULL;
}
#+end_src

现在 =counter= 一定是 2,000,000。

* 锁: 互斥的基本实现

** 锁的语义

锁 (lock/mutex) 有两个基本性质:

1. *互斥性*: 同一时刻只能有一个线程持有锁
2. *进度性*: 如果没有线程持有锁，试图获取锁的线程最终能成功

** 两个原子操作: 获取和释放

- =lock()= / =acquire()=: 原子操作，如果锁已被持有则阻塞，否则获取锁
- =unlock()= / =release()=: 原子操作，释放锁并唤醒等待的线程

** 原子操作的定义

*原子操作* (atomic operation) 的定义:

#+begin_quote
一个操作在执行过程中 *不可被中断*，从其他线程的视角看，该操作要么 *完全执行完成*，要么 *完全未执行*，不存在 "执行到一半" 的中间状态。
#+end_quote

在硬件层面，现代 CPU 提供原子指令:

*** x86 的原子指令

- =lock= 前缀: 锁住缓存线或总线，保证单条指令的原子性

#+begin_src asm
lock inc dword ptr [counter]    ; 原子地 +1
lock cmpxchg [lock], new_val    ; 原子的 Compare-And-Swap
#+end_src

- =cmpxchg= (Compare-And-Exchange): CAS 操作的硬件实现

#+begin_src c
// 伪代码: CAS 的语义
bool compare_and_swap(int* ptr, int expected, int new_val) {
    if (*ptr == expected) {
        *ptr = new_val;
        return true;
    }
    return false;
}
#+end_src

*** ARM 的原子指令

ARM 使用 *Load-Link / Store-Conditional* (LL/SC):

#+begin_src asm
retry:
    ldrex r0, [counter]    ; Load Exclusive (加载并监视)
    add   r0, r0, #1       ; 计算新值
    strex r1, r0, [counter]; Store Exclusive (如果监视成功则写入)
    cmp   r1, #0           ; r1 == 0 表示成功
    bne   retry            ; 失败则重试
#+end_src

** 用户态自旋锁实现

用 CAS 实现简单的自旋锁:

#+begin_src c
typedef struct {
    int locked;  // 0 = 未锁定, 1 = 已锁定
} spinlock_t;

void spin_lock(spinlock_t* lock) {
    while (!__sync_bool_compare_and_swap(&lock->locked, 0, 1)) {
        // 自旋等待
        __asm__ volatile("pause");  // x86: 降低功耗，优化自旋
    }
}

void spin_unlock(spinlock_t* lock) {
    __sync_lock_release(&lock->locked);  // 原子地写 0
}
#+end_src

*问题*: 自旋锁在争用严重时会 *浪费 CPU*，持续轮询消耗算力。

** Futex: 快速用户态互斥锁

Linux 的 =pthread_mutex= 实际上是 *futex* (fast userspace mutex) 实现的:

1. *快路径* (无争用): 纯用户态 CAS，~40-120 cycles
2. *慢路径* (有争用): 调用 =futex()= 系统调用进入内核，让线程休眠

#+begin_src c
// glibc 的简化实现
int pthread_mutex_lock(pthread_mutex_t* mutex) {
    if (__sync_bool_compare_and_swap(&mutex->lock, 0, 1)) {
        return 0;  // 快路径: 无争用
    }
    // 慢路径: 有争用
    return futex_wait(&mutex->lock, 1);  // 进入内核休眠
}
#+end_src

这样在无争用时避免系统调用开销，有争用时避免 CPU 空转。

* 信号量: 通用的同步原语

** 信号量的定义

信号量 (semaphore) 本质上是 *带计数的锁*，由荷兰计算机科学家 Edsger Dijkstra 在 1965 年提出。

信号量有一个整数值和两个原子操作:

- *P 操作* (=wait()= / =down()=): 原子操作，等待信号量变为正数，然后将其减 1
- *V 操作* (=post()= / =up()=): 原子操作，将信号量 +1，如果有线程在等待，唤醒一个

#+begin_quote
*历史注记*: P 和 V 来自荷兰语:
- P = *Proberen* (尝试, try)
- V = *Verhogen* (增加, increment)
#+end_quote

** POSIX 信号量 API

#+begin_src c
#include <semaphore.h>

sem_t sem;
sem_init(&sem, 0, 1);  // 初始化为 1

sem_wait(&sem);   // P 操作: 减 1，如果为 0 则阻塞
// 临界区
sem_post(&sem);   // V 操作: 加 1，唤醒等待线程
#+end_src

** 信号量的用途

*** 1. 互斥锁 (初始值 = 1)

如果信号量的初始值为 1，其行为等同于 *互斥锁* (mutex)，此时被称为 *二元信号量* (binary semaphore) 或 *互斥量*。

#+begin_src c
sem_t mutex;
sem_init(&mutex, 0, 1);  // 初始值 = 1

void critical_section() {
    sem_wait(&mutex);  // 获取锁
    // 只有一个线程能进入
    sem_post(&mutex);  // 释放锁
}
#+end_src

*** 2. 资源计数 (初始值 = N)

如果初始值为 N，可以限制 *最多 N 个线程* 同时访问资源。

#+begin_src c
sem_t pool;
sem_init(&pool, 0, 5);  // 最多 5 个线程

void use_resource() {
    sem_wait(&pool);  // 获取一个资源
    // 使用资源 (如数据库连接)
    sem_post(&pool);  // 归还资源
}
#+end_src

*** 3. 事件通知 (初始值 = 0)

初始值为 0 的信号量可以用于 *线程同步*。

#+begin_src c
sem_t ready;
sem_init(&ready, 0, 0);  // 初始值 = 0

// 生产者
void producer() {
    prepare_data();
    sem_post(&ready);  // 通知: 数据准备好了
}

// 消费者
void consumer() {
    sem_wait(&ready);  // 阻塞等待通知
    process_data();
}
#+end_src

** 信号量 vs. 互斥锁

| 特性     | 互斥锁 (Mutex)         | 信号量 (Semaphore)    |
|--------|-----------------------|-----------------------|
| 用途     | 互斥访问临界区           | 通用同步、资源计数      |
| 所有权   | 有 (必须由加锁线程解锁)   | 无 (任何线程都能操作)   |
| 初始值   | 固定 (0 或 1)          | 任意非负整数           |
| 嵌套     | 可递归 (recursive mutex) | 不支持                |

* 进程管理: fork-exec-wait 模型

** 线程 vs. 进程

*** 线程的特点

- *共享*: 堆内存、全局变量、代码段、打开的文件描述符
- *独立*: 栈、寄存器、线程 ID、信号掩码

每个线程有自己的 *线程控制块* (TCB, Thread Control Block)，保存:
- 寄存器状态 (PC, SP, 通用寄存器)
- 栈指针
- 线程状态 (运行/阻塞/就绪)
- 优先级

#+begin_src c
// Linux 内核的 task_struct (简化)
struct task_struct {
    void* stack;                // 栈指针
    struct pt_regs* regs;       // 寄存器快照
    int state;                  // TASK_RUNNING, TASK_INTERRUPTIBLE...
    struct mm_struct* mm;       // 内存描述符 (进程间不共享)
    struct files_struct* files; // 文件描述符表 (线程间共享)
};
#+end_src

*** 进程的特点

进程是 *资源分配的基本单位*，每个进程有独立的:
- 地址空间 (页表)
- 文件描述符表
- 信号处理程序
- 进程 ID (PID)

** fork(): 克隆进程

=fork()= 系统调用创建一个新进程，复制父进程的 *所有资源*:

#+begin_src c
#include <unistd.h>

pid_t pid = fork();

if (pid < 0) {
    // 失败 (如系统资源不足)
    perror("fork failed");
} else if (pid == 0) {
    // 子进程 (返回值 = 0)
    printf("I am child, PID = %d\n", getpid());
} else {
    // 父进程 (返回值 = 子进程的 PID)
    printf("I am parent, child PID = %d\n", pid);
}
#+end_src

*** fork() 的实现: Copy-on-Write

现代操作系统使用 *写时复制* (Copy-on-Write, COW) 优化:

1. =fork()= 时，子进程的页表 *指向父进程的物理页*
2. 两个进程的页表项都标记为 *只读*
3. 当任一进程尝试写入时，触发 *缺页中断* (page fault)
4. 内核此时才复制该页，修改页表

这样避免了不必要的内存复制，大幅提升性能。

#+begin_example
fork() 前:
  Parent: VA 0x1000 → PA 0x5000 (可写)

fork() 后:
  Parent: VA 0x1000 → PA 0x5000 (只读)
  Child:  VA 0x1000 → PA 0x5000 (只读)  ← 共享物理页

Parent 写入 0x1000:
  触发 page fault
  → 内核分配新物理页 0x6000
  → 复制 0x5000 的内容到 0x6000
  → Parent: VA 0x1000 → PA 0x6000 (可写)
  → Child:  VA 0x1000 → PA 0x5000 (可写)
#+end_example

** exec(): 替换进程映像

=exec= 族系统调用 *丢弃当前进程的地址空间*，加载新程序:

#+begin_src c
#include <unistd.h>

// 在子进程中执行新程序
if (fork() == 0) {
    // exec 不返回 (除非失败)
    execl("/bin/ls", "ls", "-l", NULL);
    perror("exec failed");  // 只有失败才会执行到这里
    exit(1);
}
#+end_src

*** exec 族函数

| 函数         | 参数形式   | 搜索 PATH | 传递环境变量 |
|------------|----------|----------|------------|
| =execl=      | 列表       | 否       | 否         |
| =execlp=     | 列表       | 是       | 否         |
| =execle=     | 列表       | 否       | 是         |
| =execv=      | 数组       | 否       | 否         |
| =execvp=     | 数组       | 是       | 否         |
| =execve=     | 数组       | 否       | 是         |

最底层的是 =execve()= 系统调用，其他都是库函数封装。

#+begin_src c
// 内核实现的唯一 exec
int execve(const char* filename, char* const argv[], char* const envp[]);
#+end_src

** wait(): 等待子进程退出

父进程用 =wait()= 或 =waitpid()= 等待子进程结束:

#+begin_src c
#include <sys/wait.h>

pid_t child_pid = fork();
if (child_pid == 0) {
    // 子进程
    exit(42);  // 退出码 42
}

// 父进程
int status;
pid_t pid = wait(&status);  // 阻塞等待任一子进程
if (WIFEXITED(status)) {
    printf("Child %d exited with code %d\n", pid, WEXITSTATUS(status));
}
#+end_src

*** 僵尸进程 (Zombie Process)

如果父进程 *没有调用 wait()*，子进程退出后会变成 *僵尸进程*:

- 进程已死，但 PCB 仍在内核中
- 占用 PID 和少量内核内存
- =ps= 显示为 =<defunct>=

#+begin_src bash
$ ps aux | grep defunct
user  1234  0.0  0.0     0    0 ?  Z  10:00  0:00 [child] <defunct>
#+end_src

*清理僵尸进程*:

1. 父进程调用 =wait()=
2. 父进程退出 (子进程被 init 收养, PID 1)
3. 杀死父进程: =kill -9 <parent_pid>=

*** 孤儿进程 (Orphan Process)

如果 *父进程先退出*，子进程变成孤儿，被 =init= (PID 1) 或 =systemd= 收养。

#+begin_src c
if (fork() == 0) {
    sleep(10);  // 子进程存活 10 秒
    printf("My parent is now %d\n", getppid());  // 输出 1
    exit(0);
}
// 父进程立刻退出
exit(0);
#+end_src

* 信号机制: 异步事件通知

** 信号的本质

信号 (signal) 是 *软件中断*，用于通知进程发生了某个事件。信号是 *异步* 的，可以在任意时刻打断进程。

** POSIX 标准信号

| 信号          | 编号 | 默认动作 | 触发条件              |
|-------------|-----|---------|-----------------------|
| =SIGINT=      |  2  | 终止     | Ctrl-C               |
| =SIGQUIT=     |  3  | 终止+核心转储 | Ctrl-\        |
| =SIGKILL=     |  9  | 终止     | 不可捕获/忽略         |
| =SIGSEGV=     | 11  | 终止+核心转储 | 段错误 (非法内存访问) |
| =SIGTERM=     | 15  | 终止     | =kill= 命令默认信号   |
| =SIGSTOP=     | 19  | 停止     | 不可捕获/忽略         |
| =SIGTSTP=     | 20  | 停止     | Ctrl-Z               |
| =SIGCHLD=     | 17  | 忽略     | 子进程状态改变        |
| =SIGUSR1/2=   | 10/12 | 终止   | 用户自定义            |

完整列表: =man 7 signal=

** 信号处理: sigaction

=sigaction()= 是现代推荐的信号处理 API (替代过时的 =signal()=):

#+begin_src c
#include <signal.h>

void sigint_handler(int sig) {
    printf("Caught SIGINT, cleaning up...\n");
    exit(0);
}

int main() {
    struct sigaction sa;
    sa.sa_handler = sigint_handler;  // 回调函数
    sigemptyset(&sa.sa_mask);        // 清空信号掩码
    sa.sa_flags = 0;                 // 无特殊标志

    if (sigaction(SIGINT, &sa, NULL) == -1) {
        perror("sigaction");
        return 1;
    }

    while (1) {
        printf("Press Ctrl-C to exit\n");
        sleep(1);
    }
}
#+end_src

*** 信号掩码 (Signal Mask)

每个线程有一个 *信号掩码*，阻塞特定信号:

#+begin_src c
sigset_t mask;
sigemptyset(&mask);
sigaddset(&mask, SIGINT);   // 添加 SIGINT 到掩码
sigprocmask(SIG_BLOCK, &mask, NULL);  // 阻塞 SIGINT

// 现在 Ctrl-C 不会中断程序
sleep(5);

sigprocmask(SIG_UNBLOCK, &mask, NULL);  // 解除阻塞
#+end_src

*** 不可捕获的信号

=SIGKILL= (9) 和 =SIGSTOP= (19) *不能被捕获、阻塞或忽略*，是内核强制执行的终极手段。

#+begin_src bash
# 正常终止 (可被捕获)
kill 1234         # SIGTERM (15)

# 强制杀死 (不可捕获)
kill -9 1234      # SIGKILL

# 暂停进程 (不可捕获)
kill -STOP 1234   # SIGSTOP
kill -CONT 1234   # SIGCONT (恢复)
#+end_src

** 信号的异步性陷阱

信号处理函数在 *任意时刻* 被调用，可能打断正在执行的代码，导致 *可重入性* (reentrancy) 问题。

#+begin_src c
int global = 0;

void handler(int sig) {
    global++;  // 不安全！
}

int main() {
    signal(SIGINT, handler);
    global++;  // 如果信号在这里到达，global 可能被破坏
}
#+end_src

*安全的信号处理函数* 只能调用 *异步信号安全* (async-signal-safe) 的函数，列表见 =man 7 signal-safety=。

安全的函数包括: =write()=, =_exit()=, =sigaction()=, ...

*不安全* 的函数: =printf()=, =malloc()=, =pthread_mutex_lock()=, ...

正确做法:

#+begin_src c
volatile sig_atomic_t flag = 0;  // sig_atomic_t 保证原子读写

void handler(int sig) {
    flag = 1;  // 只设置标志
}

int main() {
    signal(SIGINT, handler);
    while (1) {
        if (flag) {
            printf("Got signal\n");  // 在主循环中处理
            break;
        }
        sleep(1);
    }
}
#+end_src

* POSIX 标准: 可移植性的基石

** POSIX 是什么？

*POSIX* = Portable Operating System Interface for uniX

由 IEEE 制定的操作系统标准，定义了:
- 系统调用接口
- Shell 命令
- 库函数
- 线程 API (POSIX Threads, pthreads)

** POSIX 的历史

| 年份  | 版本       | 重要特性                   |
|------|-----------|---------------------------|
| 1988 | POSIX.1   | 基本系统调用 (fork, open, read) |
| 1990 | POSIX.1b  | 实时扩展 (信号量, 定时器)     |
| 1995 | POSIX.1c  | 线程 API (pthread)        |
| 2001 | POSIX:2001 | 整合所有标准, SUSv3       |
| 2008 | POSIX:2008 | 当前广泛使用的版本         |
| 2017 | POSIX:2017 | 最新版本                  |

** 系统调用 vs. 库函数

*POSIX 不区分* 系统调用还是库函数实现，只要求接口存在。

*** 系统调用 (内核实现)

- =fork()=, =exec()=, =wait()=
- =open()=, =read()=, =write()=, =close()=
- =mmap()=, =brk()=

在用户态通过 =syscall= 指令陷入内核:

#+begin_src asm
; x86-64 系统调用
mov rax, 1       ; syscall number (1 = write)
mov rdi, 1       ; fd (1 = stdout)
mov rsi, buf     ; buffer
mov rdx, len     ; length
syscall          ; 陷入内核
#+end_src

*** 库函数 (glibc/musl 实现)

- =pthread_create()=, =pthread_join()=
- =opendir()=, =readdir()=
- =printf()=, =malloc()=

可能内部调用多个系统调用:

#+begin_src c
// printf() 的简化实现
int printf(const char* fmt, ...) {
    char buf[4096];
    va_list ap;
    va_start(ap, fmt);
    int n = vsnprintf(buf, sizeof(buf), fmt, ap);  // 格式化 (纯用户态)
    va_end(ap);
    return write(1, buf, n);  // 系统调用
}
#+end_src

** 检查 POSIX 兼容性

#+begin_src c
#include <unistd.h>
#include <stdio.h>

int main() {
    #ifdef _POSIX_VERSION
        printf("POSIX version: %ld\n", _POSIX_VERSION);
    #endif

    #ifdef _POSIX_THREADS
        printf("POSIX threads supported\n");
    #endif

    return 0;
}
#+end_src

编译运行:

#+begin_example
$ gcc -o test test.c
$ ./test
POSIX version: 200809
POSIX threads supported
#+end_example

* 文件系统抽象: Everything is a File

** Unix 哲学

#+begin_quote
"一切皆文件" (Everything is a file)
— Ken Thompson & Dennis Ritchie
#+end_quote

在 Unix 中，几乎所有 I/O 对象都用 *文件接口* 抽象:

- 普通文件
- 目录
- 设备 (=/dev/sda=, =/dev/null=)
- 管道 (pipe)
- Socket (网络连接)
- 终端 (=/dev/tty=)

** 通用文件接口

所有文件操作通过 4 个基本系统调用:

#+begin_src c
int fd = open("/path/to/file", O_RDWR | O_CREAT, 0644);
ssize_t n = read(fd, buf, sizeof(buf));
ssize_t n = write(fd, data, len);
close(fd);
#+end_src

对于不符合这 4 个接口的操作，使用 *万能的* =ioctl()=:

#+begin_src c
#include <sys/ioctl.h>

// 获取终端窗口大小
struct winsize ws;
ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws);
printf("Terminal: %d rows x %d cols\n", ws.ws_row, ws.ws_col);
#+end_src

** 文件描述符 (File Descriptor)

文件描述符是一个 *非负整数*，索引进程的 *文件描述符表*。

*** 特殊的文件描述符

| FD  | 宏定义             | 用途       |
|-----|------------------|-----------|
| 0   | =STDIN_FILENO=     | 标准输入   |
| 1   | =STDOUT_FILENO=    | 标准输出   |
| 2   | =STDERR_FILENO=    | 标准错误   |

#+begin_src c
write(STDOUT_FILENO, "Hello\n", 6);  // 等同于 printf("Hello\n");
#+end_src

*** 文件描述符的实现

每个进程有一个 *打开文件表* (open file table)，内核全局有一个 *文件表* (file table):

#+begin_example
进程 A:
  fd 0 → file table entry 1 → inode /dev/pts/0 (终端)
  fd 1 → file table entry 2 → inode /var/log/a.log
  fd 3 → file table entry 3 → inode /tmp/test.txt

进程 B:
  fd 0 → file table entry 1 → inode /dev/pts/0 (共享)
  fd 1 → file table entry 4 → inode /var/log/b.log
#+end_example

=fork()= 后子进程 *继承* 父进程的文件描述符，共享 file table entry (包括文件偏移量)。

** 文件系统层次

文件系统是 *被命名的一串数据袋*:

#+begin_example
/
├── bin/         # 可执行文件
├── etc/         # 配置文件
├── home/        # 用户目录
│   └── sov710/
│       └── notes.org
├── dev/         # 设备文件
│   ├── sda      # 硬盘
│   └── null     # 位桶
└── proc/        # 虚拟文件系统
    ├── cpuinfo  # CPU 信息
    └── meminfo  # 内存信息
#+end_example

*** 目录是特殊的文件

目录本身是一个文件，内容是 *文件名 → inode* 的映射:

#+begin_example
目录 /home/sov710/ 的内容:
  .          → inode 12345
  ..         → inode 67890
  notes.org  → inode 11111
  code/      → inode 22222
#+end_example

可以用 =open()= 打开目录 (需要 =O_DIRECTORY= 标志)，但 =read()= 会失败，要用 =readdir()=:

#+begin_src c
DIR* dir = opendir("/home/sov710");
struct dirent* entry;
while ((entry = readdir(dir)) != NULL) {
    printf("%s (inode %ld)\n", entry->d_name, entry->d_ino);
}
closedir(dir);
#+end_src

** 当前工作目录 (cwd)

每个进程有一个 *当前工作目录* (current working directory):

#+begin_src c
char cwd[1024];
getcwd(cwd, sizeof(cwd));
printf("CWD: %s\n", cwd);

chdir("/tmp");  // 切换到 /tmp
#+end_src

相对路径基于 cwd 解析:

#+begin_example
cwd = /home/sov710
open("notes.org", ...)  → 打开 /home/sov710/notes.org
#+end_example

** =~= 只是 Shell 的功能

*重要*: 波浪号 (=~=) 是 *Shell 展开*，不是操作系统功能！

#+begin_src bash
# Shell 会把 ~ 替换为 $HOME
cd ~/notes
# 实际调用: chdir("/home/sov710/notes")
#+end_src

但在 C 程序中:

#+begin_src c
open("~/notes.org", O_RDONLY);  // 失败！找不到文件 "~/notes.org"
#+end_src

必须手动展开:

#+begin_src c
const char* home = getenv("HOME");
char path[1024];
snprintf(path, sizeof(path), "%s/notes.org", home);
open(path, O_RDONLY);
#+end_src

* 高级 I/O: 流与缓冲

** 流 (Stream) 的概念

流是 *无格式的字节序列*，可以是:
- 文本 (text stream): 以换行符分隔的行
- 二进制 (binary stream): 任意字节

Unix *不关心* 文件格式，一切都是字节流。

#+begin_quote
"Unix doesn't care what's in your files."
— Dennis Ritchie
#+end_quote

** FILE* 抽象

标准 I/O 库 (stdio) 提供 *带缓冲的流*:

#+begin_src c
#include <stdio.h>

FILE* fp = fopen("test.txt", "r");
if (fp == NULL) {
    perror("fopen");
    return 1;
}

char buf[256];
while (fgets(buf, sizeof(buf), fp) != NULL) {
    printf("%s", buf);
}

fclose(fp);
#+end_src

*** FILE* 的实现

=FILE= 结构体 (glibc) 包含:

#+begin_src c
struct _IO_FILE {
    int _fileno;          // 底层文件描述符
    char* _IO_buf_base;   // 缓冲区起始
    char* _IO_buf_end;    // 缓冲区结束
    char* _IO_read_ptr;   // 当前读位置
    char* _IO_write_ptr;  // 当前写位置
    // ... 更多字段
};
#+end_src

*** 缓冲策略

| 模式       | 说明                   | 典型用途    |
|----------|----------------------|-----------|
| 全缓冲     | 缓冲区满或 =fflush()= 时刷新 | 普通文件   |
| 行缓冲     | 遇到换行符时刷新          | 终端 (stdout) |
| 无缓冲     | 立刻写入                | stderr    |

#+begin_src c
setbuf(stdout, NULL);  // 禁用缓冲
setvbuf(fp, buf, _IOLBF, 1024);  // 行缓冲, 1KB
#+end_src

** 标准流

每个进程自动打开 3 个流:

#+begin_src c
extern FILE* stdin;   // fd 0
extern FILE* stdout;  // fd 1
extern FILE* stderr;  // fd 2
#+end_src

*** stdout vs. stderr

- =stdout=: 行缓冲 (遇到 =\n= 刷新)
- =stderr=: 无缓冲 (立刻输出)

#+begin_src c
printf("Normal message\n");  // 可能延迟
fprintf(stderr, "Error!\n"); // 立刻显示
#+end_src

这样在重定向时，错误信息总是实时显示:

#+begin_src bash
./program > output.log 2> error.log
# stdout 写入 output.log (缓冲)
# stderr 写入 error.log (无缓冲)
#+end_src

** 进程退出时的自动清理

如果程序 *正常退出* (=exit()= 或 =return=)，标准库会:

1. 调用所有注册的 =atexit()= 回调
2. 刷新所有打开的流 (=fflush(NULL)=)
3. 关闭所有文件 (调用 =fclose()=)
4. 释放内存 (在内核回收地址空间时自动完成)

如果 *异常退出* (=_exit()= 或 =SIGKILL=)，缓冲区数据 *会丢失*！

#+begin_src c
// 危险: 缓冲区数据可能丢失
printf("Important data");  // 没有 \n, 留在缓冲区
_exit(0);  // 直接退出, 不刷新

// 安全做法
printf("Important data\n");  // 有 \n, 立刻刷新
exit(0);

// 或者显式刷新
printf("Important data");
fflush(stdout);
exit(0);
#+end_src

* 管道: 进程间通信

** 匿名管道 (Anonymous Pipe)

管道是 Unix 最经典的 IPC 机制:

#+begin_src c
int pipefd[2];
pipe(pipefd);  // pipefd[0] = 读端, pipefd[1] = 写端

if (fork() == 0) {
    // 子进程: 读取
    close(pipefd[1]);  // 关闭写端
    char buf[100];
    read(pipefd[0], buf, sizeof(buf));
    printf("Child received: %s\n", buf);
    close(pipefd[0]);
    exit(0);
}

// 父进程: 写入
close(pipefd[0]);  // 关闭读端
write(pipefd[1], "Hello from parent", 18);
close(pipefd[1]);
wait(NULL);
#+end_src

** Shell 管道符 =|=

Shell 的管道符 =|= 背后是 =pipe()= + =dup2()=:

#+begin_src bash
ls | grep txt
#+end_src

等价于:

#+begin_src c
int pipefd[2];
pipe(pipefd);

if (fork() == 0) {
    // 子进程 1: ls
    dup2(pipefd[1], STDOUT_FILENO);  // 重定向 stdout 到管道写端
    close(pipefd[0]);
    close(pipefd[1]);
    execlp("ls", "ls", NULL);
}

if (fork() == 0) {
    // 子进程 2: grep
    dup2(pipefd[0], STDIN_FILENO);   // 重定向 stdin 到管道读端
    close(pipefd[0]);
    close(pipefd[1]);
    execlp("grep", "grep", "txt", NULL);
}

// 父进程
close(pipefd[0]);
close(pipefd[1]);
wait(NULL);
wait(NULL);
#+end_src

** 管道的特性

*** 1. 单向通信

管道是 *单向* 的，数据只能从写端流向读端。双向通信需要两个管道。

*** 2. 阻塞行为

- =read()=: 如果管道为空且有写端存活，*阻塞等待*
- =write()=: 如果管道满 (默认 64 KB)，*阻塞等待*
- 如果 *所有写端关闭*，=read()= 返回 0 (EOF)
- 如果 *所有读端关闭*，=write()= 触发 =SIGPIPE= 信号 (默认终止进程)

*** 3. 原子性

写入 ≤ =PIPE_BUF= (通常 4 KB) 的数据是 *原子的*，不会与其他进程的写入交错。

** 命名管道 (FIFO)

=mkfifo()= 创建 *文件系统中的管道*，允许无亲缘关系的进程通信:

#+begin_src bash
# 创建命名管道
mkfifo /tmp/mypipe

# 终端 1: 读取
cat < /tmp/mypipe

# 终端 2: 写入
echo "Hello" > /tmp/mypipe
#+end_src

在 C 中:

#+begin_src c
mkfifo("/tmp/mypipe", 0666);

// 进程 A
int fd = open("/tmp/mypipe", O_WRONLY);
write(fd, "data", 4);
close(fd);

// 进程 B
int fd = open("/tmp/mypipe", O_RDONLY);
char buf[100];
read(fd, buf, sizeof(buf));
close(fd);
#+end_src

* 总结: Unix 的设计哲学

Unix 操作系统的核心理念:

1. *一切皆文件*: 统一接口抽象 I/O
2. *进程独立*: 地址空间隔离
3. *管道组合*: 小工具通过管道协作
4. *POSIX 标准*: 可移植性

#+begin_quote
"Write programs that do one thing and do it well.
Write programs to work together.
Write programs to handle text streams, because that is a universal interface."
— Doug McIlroy, Unix 哲学
#+end_quote

这些设计原则历经 50 年仍然是现代操作系统的基石。理解这些机制，是掌握系统编程和操作系统内核的第一步。
