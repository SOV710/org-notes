#+title: ARM Cortex-M Development Ecosystem: From CMSIS to Debug Infrastructure
#+author: SOV710
#+date: 2025-12-23
#+startup: showall
#+options: toc:2 num:nil

* ARM Cortex-M 软件生态概览

** CMSDK: Cortex-M System Design Kit

CMSDK (Cortex-M System Design Kit) 是 ARM 提供的 *硬件设计参考*，包含:

- *示例 SoC 设计*: 预集成的总线矩阵、外设控制器、时钟/复位模块
- *验证组件*: Testbench、仿真脚本 (适用于 ModelSim/VCS)
- *参考手册*: 寄存器映射、时序图、集成指南

CMSDK 主要面向 *芯片设计者*，而非嵌入式软件开发者。MCU 厂商 (如 ST、NXP) 基于 CMSDK 设计自己的 SoC，然后提供给软件开发者。

** CMSIS: Cortex Microcontroller Software Interface Standard

CMSIS (Cortex Microcontroller Software Interface Standard) 是 ARM 官方定义的 *软件抽象层*，让你写 Cortex-M 程序时不用直接操作寄存器地址。

*** CMSIS 的分层架构

CMSIS 包含多个层次:

**** CMSIS-Core

提供 *标准化的 CPU 访问接口*:

#+begin_src c
// 不需要记住 NVIC 寄存器地址
NVIC_EnableIRQ(TIM2_IRQn);       // 使能中断
NVIC_SetPriority(TIM2_IRQn, 3);  // 设置优先级

// 不需要记住 SysTick 寄存器布局
SysTick_Config(SystemCoreClock / 1000);  // 1ms 中断

// 标准化的内存屏障
__DSB();  // Data Synchronization Barrier
__ISB();  // Instruction Synchronization Barrier
#+end_src

CMSIS-Core 定义了:

- *中断向量表* (=IRQn_Type=)
- *系统控制寄存器* (SCB, System Control Block)
- *NVIC 操作函数* (嵌套向量中断控制器)
- *MPU 配置函数* (内存保护单元, Cortex-M3/M4/M7)
- *FPU 控制* (浮点单元, Cortex-M4F/M7)

**** CMSIS-Driver

提供 *标准化的外设驱动接口*:

#+begin_src c
// 所有厂商的 SPI 驱动都有相同的 API
extern ARM_DRIVER_SPI Driver_SPI0;

Driver_SPI0.Initialize(SPI_Callback);
Driver_SPI0.PowerControl(ARM_POWER_FULL);
Driver_SPI0.Send(tx_buf, 10);
#+end_src

好处:

- *跨厂商移植*: 从 STM32 切换到 NXP LPC，只需换驱动实现，应用代码不变
- *RTOS 集成*: RTX、FreeRTOS 等可以直接使用 CMSIS-Driver

**** CMSIS-RTOS

提供 *标准化的 RTOS API*:

#+begin_src c
osThreadId tid = osThreadCreate(osThread(MyThread), NULL);
osMutexId mid = osMutexCreate(osMutex(MyMutex));
osMutexWait(mid, osWaitForever);
// critical section
osMutexRelease(mid);
#+end_src

支持多种 RTOS 后端:

- ARM RTX (Keil)
- FreeRTOS
- Zephyr

**** CMSIS-DSP

提供 *优化的 DSP 库*:

#+begin_src c
// 快速傅里叶变换
arm_rfft_fast_f32(&S, input, output, 0);

// FIR 滤波器
arm_fir_f32(&S, input, output, blockSize);

// 矩阵运算
arm_mat_mult_f32(&A, &B, &C);
#+end_src

针对 Cortex-M4/M7 的 *SIMD 指令* (Single Instruction Multiple Data) 优化，性能远超纯 C 实现。

**** CMSIS-NN

神经网络库，针对 Cortex-M4/M7/M55 优化:

#+begin_src c
// 卷积层
arm_convolve_HWC_q7_basic(input, conv_params, output);

// 全连接层
arm_fully_connected_q7(input, weights, output);
#+end_src

用于 TinyML (边缘 AI 推理)。

*** 为什么需要 CMSIS？

*问题*: 不同厂商的 MCU，即使用同样的 Cortex-M 核心，寄存器布局也不同:

#+begin_src c
// STM32 的 GPIO
GPIOA->ODR |= (1 << 5);  // PA5 置高

// NXP LPC 的 GPIO
LPC_GPIO0->SET = (1 << 5);

// TI Tiva 的 GPIO
GPIO_PORTA_DATA_R |= 0x20;
#+end_src

*CMSIS 的解决*: 统一抽象层，隐藏厂商差异:

#+begin_src c
// CMSIS-Driver 统一接口
Driver_GPIO.SetDirection(0, 5, ARM_GPIO_OUTPUT);
Driver_GPIO.SetOutput(0, 5, 1);
#+end_src

但实际上，大多数开发者还是用 *HAL (Hardware Abstraction Layer)*:

- STM32: STM32Cube HAL
- NXP: MCUXpresso SDK
- TI: TivaWare / MSP430Ware

HAL 比 CMSIS 更贴近硬件，功能更完整，但 *不跨厂商*。

* Debug Adaptor: 连接 PC 和 MCU 的桥梁

** Debug Adaptor 的作用

Debug adaptor (调试适配器) 负责将 *USB 连接* 中发送的交互信号，转换为微处理器上的 *debug 信号* (SWD 或 JTAG)。

#+begin_example
PC (GDB/IDE)  <--USB-->  Debug Adaptor  <--SWD/JTAG-->  MCU
#+end_example

*** 工作流程

1. *PC 端*: IDE (如 Keil/IAR/VS Code) 通过 GDB Server 发送调试命令
2. *Debug Adaptor*: 接收 USB 数据包，解析为 SWD/JTAG 时序
3. *MCU*: 通过 CoreSight DAP 执行指令 (读写内存、设置断点、单步执行)
4. *回传*: MCU 状态返回给 PC

** 主流 Debug Adaptor 产品

*** 商用产品

**** ST-Link (STMicroelectronics)

- *价格*: ¥100~300 (ST-Link/V2, V3)
- *协议*: SWD (主), JTAG
- *功能*:
  - 烧录 Flash
  - 实时调试
  - 虚拟串口 (VCP, Virtual COM Port)
- *缺点*: 只支持 STM32 系列 (其他厂商 MCU 需要魔改固件)

**** SEGGER J-Link (行业标准)

- *价格*: ¥2,000~20,000 (J-Link BASE/PLUS/ULTRA+)
- *协议*: SWD, JTAG, SPI, I²C (高端型号)
- *功能*:
  - *实时跟踪* (RTT, Real-Time Transfer): 无需 UART，通过 SWD 实时打印日志
  - *Flash 下载速度*: 最高 3 MB/s (J-Link ULTRA+)
  - *指令跟踪*: ETM (Embedded Trace Macrocell) 支持
  - *能量分析*: J-Link PLUS 内置功耗测量
- *支持*: 几乎所有 ARM Cortex-M/A/R, RISC-V
- *缺点*: 贵

**** Keil ULINK (ARM 官方)

- *价格*: ¥1,500~8,000 (ULINK2/PRO/PLUS)
- *协议*: SWD, JTAG
- *功能*:
  - 与 Keil MDK 深度集成
  - ULINK PRO: 支持 ETM 指令跟踪
- *缺点*: 仅限 Keil MDK 使用

**** IAR I-Jet

- *价格*: ¥5,000~15,000
- *协议*: SWD, JTAG
- *功能*: 与 IAR Embedded Workbench 集成
- *缺点*: 昂贵，仅限 IAR 用户

*** 开源 / 低成本方案

**** CMSIS-DAP / DAPLink

*CMSIS-DAP* 是 ARM 官方定义的 *开放标准协议*，用于通过 USB 抽象访问 CoreSight DAP。

*DAPLink* 是基于 CMSIS-DAP 的 *开源固件* (GitHub: ARMmbed/DAPLink)，功能:

1. *USB HID/Bulk CMSIS-DAP 调试接口*
2. *CDC-ACM 虚拟串口*: 自动桥接 MCU 的 UART (如 STM32 的 PA9/PA10)
   #+begin_example
   PC 看到: /dev/ttyACM0
   实际连接: PC <--USB--> DAPLink <--UART--> Target MCU
   #+end_example
3. *U 盘拖拽烧录*:
   - 插上板子，PC 识别为 U 盘 (Mass Storage)
   - 把 =firmware.hex= 或 =firmware.bin= 拖进去
   - DAPLink 自动烧录到 MCU Flash

*常见 DAPLink 板*:

- *MCU-Link* (NXP): ¥150, 支持 SWD + 高速 USB
- *LPC-Link2* (NXP): 改为 CMSIS-DAP 模式
- *WeAct Studio 调试器*: ¥30~50 (淘宝)
- *DAP-Link OB*: STM32F103/STM32F072 做主控

*优势*:

- *便宜*: ¥30 起
- *开源*: 可以自己编译固件，添加功能
- *跨平台*: Linux/macOS/Windows 免驱

*缺点*:

- 烧录速度较慢 (< 100 KB/s)
- 无高级功能 (ETM 跟踪、能量分析)

**** Black Magic Probe (BMP)

*完全开源* 的调试器 (硬件 + 固件):

- *硬件*: STM32F103 (Blue Pill 改造) 或专用 PCB
- *协议*: SWD, JTAG
- *特点*:
  - *内置 GDB Server*: 无需 OpenOCD，直接连 GDB
    #+begin_src bash
    arm-none-eabi-gdb firmware.elf
    (gdb) target extended-remote /dev/ttyACM0
    (gdb) monitor swdp_scan
    (gdb) attach 1
    (gdb) load
    #+end_src
  - *真正的开源*: GitHub: blackmagic-debug/blackmagic
  - *跨平台*: Linux/macOS 完美支持

*缺点*:

- 需要自己制作或购买 (¥50~100)
- 功能较基础

** Debug Adaptor 的别名

这些名称都指 debug adaptor:

- *Debug Probe*: 通用术语
- *USB-JTAG Adapter*: 强调 JTAG 接口
- *JTAG/SWD Emulator*: 俗称 "仿真器" (技术上不准确，现代调试器不是 "仿真")
- *JTAG ICE* (In-Circuit Emulator): 老术语，源自 Atmel AVR 时代

*注意*: 现代 ARM 调试器 *不是仿真器*！它们通过 CoreSight 直接控制真实硬件，而非仿真。

* CoreSight 调试架构: DAP, DP, AP

** DAP (Debug Access Port)

DAP (Debug Access Port) 是 ARM CoreSight 调试体系的 *核心组件*，位于 MCU 内部，负责:

- 接收调试器发来的 SWD/JTAG 信号
- 转换为 AHB/APB 总线事务
- 读写内存、寄存器、Flash
- 控制 CPU 执行 (暂停、单步、继续)

** DAP 的两层结构: DP + AP

#+begin_example
Debug Adaptor  --SWD/JTAG-->  DP (Debug Port)  --内部总线-->  AP (Access Port)  --AHB-->  CPU/Memory/Peripherals
#+end_example

*** DP (Debug Port)

DP 是 *物理接口层*，有两种实现:

**** SW-DP (Serial Wire Debug Port)

- *信号线*: SWDIO (数据), SWCLK (时钟) → *2 线*
- *速度*: 通常 1~10 MHz (部分支持 50 MHz)
- *优势*:
  - 节省引脚 (JTAG 需要 4~5 线)
  - SWD 可以与 GPIO 复用 (如 STM32 的 PA13/PA14)
- *协议*: ARM DAP 协议 (基于 SWJ-DP)

*SWD 引脚映射* (以 STM32 为例):

| SWD 信号 | GPIO | 功能          |
|----------+------+---------------|
| SWDIO    | PA13 | 双向数据线      |
| SWCLK    | PA14 | 时钟          |
| SWO      | PB3  | 单线输出 (可选) |
| NRST     | NRST | 复位 (可选)    |

*SWO (Serial Wire Output)*: 单向输出通道，用于 ITM (Instrumentation Trace Macrocell) 打印调试信息。

**** JTAG-DP (JTAG Debug Port)

- *信号线*: TDI, TDO, TCK, TMS, (TRST) → *4~5 线*
- *速度*: 通常 1~20 MHz
- *优势*:
  - 支持 *菊花链* (Daisy Chain): 多个设备串联在同一 JTAG 链上
    #+begin_example
    Debug Adaptor --> MCU1 --> MCU2 --> FPGA --> ...
    #+end_example
  - 工业标准 (IEEE 1149.1)
- *缺点*: 占用更多引脚

*JTAG 引脚映射*:

| JTAG 信号 | 功能              |
|-----------+-------------------|
| TCK       | Test Clock        |
| TMS       | Test Mode Select  |
| TDI       | Test Data In      |
| TDO       | Test Data Out     |
| TRST      | Test Reset (可选) |

*** AP (Access Port)

AP 是 *逻辑访问层*，连接到内部总线，常见类型:

**** AHB-AP (AHB Access Port)

- *功能*: 让调试器访问 *AHB 总线* (Advanced High-performance Bus)
- *用途*:
  - 读写内存 (SRAM, Flash)
  - 访问外设寄存器 (GPIO, UART, SPI...)
  - 读取 CPU 寄存器 (通过 Debug Halting Control and Status Register, DHCSR)

*示例*: 通过 GDB 读写内存

#+begin_src bash
(gdb) x/4wx 0x20000000   # 读取 SRAM 地址 0x20000000 的 4 个字
0x20000000: 0xdeadbeef 0x12345678 0xabcdef00 0x00000000

(gdb) set {int}0x20000000 = 0x11111111  # 写入值
#+end_src

底层实现: GDB → OpenOCD → SWD → DP → AHB-AP → AHB 总线 → SRAM

**** MEM-AP (Memory Access Port)

- *功能*: 专用于访问 *系统内存空间*
- *区别*: MEM-AP 是 AHB-AP 的简化版，只能访问内存，不能直接控制 CPU

**** JTAG-AP

- *功能*: 访问其他 CPU 或协处理器的调试链路
- *用途*: 多核 SoC 调试 (如 Cortex-A + Cortex-M 异构系统)

** DP 和 AP 的寄存器

*** DP 寄存器 (部分)

| 寄存器     | 地址 | 功能                      |
|-----------+------+---------------------------|
| IDCODE    |  0x0 | 读取 DP 的 ID (厂商、版本)   |
| CTRL/STAT |  0x4 | 控制/状态寄存器              |
| SELECT    |  0x8 | 选择当前操作的 AP 和寄存器地址 |
| RDBUFF    |  0xC | 读缓冲区 (用于流水线优化)     |

*** AP 寄存器 (AHB-AP 为例)

| 寄存器 | 偏移 | 功能                           |
|-------+------+--------------------------------|
| CSW   | 0x00 | 控制/状态字 (数据宽度、访问模式)     |
| TAR   | 0x04 | 传输地址寄存器 (要读写的内存地址)    |
| DRW   | 0x0C | 数据读写寄存器 (读写 TAR 指向的地址) |
| IDR   | 0xFC | AP 识别寄存器                    |

*调试器读写内存的流程*:

1. 通过 DP 的 SELECT 寄存器选择 AHB-AP
2. 写 TAR = 目标地址 (如 =0x20000000=)
3. 写 CSW = 数据宽度 (如 32-bit)
4. 读/写 DRW 寄存器 → 数据从/到目标地址

** SWD vs JTAG: 该选哪个？

| 特性          | SWD              | JTAG                  |
|---------------+------------------+-----------------------|
| 引脚数         | 2 (SWDIO, SWCLK) | 4~5 (TDI/TDO/TCK/TMS) |
| 速度          | 1~50 MHz         | 1~20 MHz              |
| 多设备支持      | 不支持菊花链       | 支持菊花链              |
| 引脚复用       | 可与 GPIO 复用    | 通常独占               |
| 跟踪输出       | SWO (1 线)       | ETM (需额外引脚)        |
| 行业标准       | ARM 专有         | IEEE 1149.1 (通用)    |
| Cortex-M 支持 | *首选*             | 也支持                 |

*推荐*:

- *Cortex-M*: 优先用 SWD (节省引脚，速度足够)
- *FPGA 或多核 SoC*: 用 JTAG (支持菊花链)
- *生产测试*: 用 JTAG (Boundary Scan 功能)

* MCU 外设驱动与接口

MCU 厂商通常提供的 C 代码和头文件包括:

- *外设寄存器定义*: 结构体映射到硬件地址
- *配置函数*: HAL (Hardware Abstraction Layer) 或 LL (Low-Layer) 库

** 外设寄存器定义

以 STM32 的 GPIO 为例:

#+begin_src c
// stm32f4xx.h (CMSIS 设备头文件)
typedef struct {
  __IO uint32_t MODER;    // 模式寄存器
  __IO uint32_t OTYPER;   // 输出类型寄存器
  __IO uint32_t OSPEEDR;  // 输出速度寄存器
  __IO uint32_t PUPDR;    // 上拉/下拉寄存器
  __IO uint32_t IDR;      // 输入数据寄存器
  __IO uint32_t ODR;      // 输出数据寄存器
  __IO uint32_t BSRR;     // 位设置/复位寄存器
  __IO uint32_t LCKR;     // 配置锁定寄存器
  __IO uint32_t AFR[2];   // 复用功能寄存器
} GPIO_TypeDef;

#define GPIOA_BASE  (AHB1PERIPH_BASE + 0x0000UL)
#define GPIOA       ((GPIO_TypeDef *)GPIOA_BASE)
#+end_src

使用:

#+begin_src c
// 配置 PA5 为推挽输出
GPIOA->MODER &= ~(0x3 << (5*2));  // 清除模式位
GPIOA->MODER |= (0x1 << (5*2));   // 设置为输出模式
GPIOA->OTYPER &= ~(1 << 5);       // 推挽输出

// 点亮 LED (PA5)
GPIOA->BSRR = (1 << 5);           // 置位
// 熄灭 LED
GPIOA->BSRR = (1 << (5+16));      // 复位
#+end_src

** 主流外设接口

*** GPIO (General Purpose Input/Output)

- *功能*: 数字 I/O
- *模式*:
  - 输入: 浮空/上拉/下拉/模拟
  - 输出: 推挽/开漏
  - 复用功能: UART_TX, SPI_MOSI...
- *速度*: Low/Medium/High/Very High (影响压摆率和功耗)

*** UART (Universal Asynchronous Receiver/Transmitter)

- *功能*: 异步串行通信
- *参数*:
  - 波特率: 9600, 115200, 921600...
  - 数据位: 7, 8, 9
  - 停止位: 1, 1.5, 2
  - 校验: None, Even, Odd
- *引脚*: TX, RX, (RTS, CTS 用于流控)
- *用途*: 调试打印、GPS 模块、蓝牙模块

*** SPI (Serial Peripheral Interface)

- *功能*: 同步串行通信 (全双工)
- *引脚*:
  - SCLK: 时钟 (Master 输出)
  - MOSI: Master Out Slave In
  - MISO: Master In Slave Out
  - NSS/CS: 片选 (低电平有效)
- *模式*:
  - Mode 0: CPOL=0, CPHA=0 (时钟空闲低，第一边沿采样)
  - Mode 1: CPOL=0, CPHA=1
  - Mode 2: CPOL=1, CPHA=0
  - Mode 3: CPOL=1, CPHA=1
- *速度*: 高达 50 MHz (取决于 MCU)
- *用途*: Flash, SD 卡, LCD, 传感器

*** I²C (Inter-Integrated Circuit)

- *功能*: 同步串行通信 (半双工)
- *引脚*:
  - SCL: 时钟
  - SDA: 数据 (双向)
- *速度*:
  - Standard: 100 kHz
  - Fast: 400 kHz
  - Fast Plus: 1 MHz
  - High Speed: 3.4 MHz
- *地址*: 7-bit 或 10-bit
- *多主机*: 支持总线仲裁
- *用途*: EEPROM, RTC, 加速度计, 温湿度传感器

*** USB (Universal Serial Bus)

- *类型*:
  - USB Device: MCU 作为设备 (虚拟串口、U 盘、HID 键盘/鼠标)
  - USB Host: MCU 作为主机 (读取 U 盘、连接鼠标)
  - USB OTG: 动态切换 Host/Device
- *速度*:
  - Low Speed: 1.5 Mbps
  - Full Speed: 12 Mbps (大多数 MCU)
  - High Speed: 480 Mbps (高端 MCU, 如 STM32H7)
- *类*:
  - CDC: 虚拟串口
  - HID: 人机接口设备
  - MSC: Mass Storage (U 盘)
  - Audio: 音频设备
- *用途*: 数据传输、固件升级、调试

*** CAN (Controller Area Network)

- *功能*: 差分总线通信
- *速度*: 高达 1 Mbps
- *特点*:
  - 多主机
  - 优先级仲裁
  - 错误检测和重传
  - 120Ω 终端电阻
- *用途*: 汽车电子、工业控制

*** Ethernet (以太网)

- *类型*:
  - 10/100 Mbps (大多数 MCU)
  - 1 Gbps (高端 MCU)
- *PHY*: 外接物理层芯片 (如 LAN8720, DP83848)
- *接口*: RMII (Reduced MII) 或 MII
- *协议栈*: LwIP (Lightweight IP)
- *用途*: 物联网、工业以太网

*** ADC (Analog-to-Digital Converter)

- *功能*: 模拟信号转数字
- *分辨率*: 8-bit, 10-bit, 12-bit, 16-bit
- *采样率*: 1 MSPS ~ 5 MSPS (Mega Samples Per Second)
- *通道*: 多通道复用 (如 16 通道)
- *模式*:
  - 单次转换
  - 连续转换
  - 扫描模式
  - DMA 传输
- *用途*: 传感器读取、音频采集、电池电压监测

*** DAC (Digital-to-Analog Converter)

- *功能*: 数字信号转模拟
- *分辨率*: 8-bit, 12-bit
- *输出*: 电压 (通常 0~3.3V)
- *用途*: 音频输出、波形生成、模拟控制信号

* 嵌入式软件开发工作流

** 1. 创建项目

*** 工具选择

**** IDE 方式

- *Keil MDK*: Windows, 收费 (¥10,000+), 集成度高
- *IAR Embedded Workbench*: 跨平台, 收费 (¥15,000+), 优化好
- *STM32CubeIDE*: 免费, 基于 Eclipse, ST 官方
- *MCUXpresso IDE*: 免费, 基于 Eclipse, NXP 官方

**** 命令行 + 编辑器

- *工具链*: =arm-none-eabi-gcc= (GNU Arm Embedded Toolchain)
- *构建系统*: CMake, Makefile
- *调试*: GDB + OpenOCD / pyOCD
- *编辑器*: VS Code, Neovim, Emacs
- *优势*:
  - 完全开源免费
  - 跨平台 (Linux/macOS/Windows)
  - 自动化友好 (CI/CD)
  - 适合 Gentoo 用户 😎

*** 项目配置

**** 交叉编译工具链

安装 =arm-none-eabi-gcc=:

#+begin_src bash
# Gentoo
emerge --ask cross-arm-none-eabi/gcc

# Ubuntu
sudo apt install gcc-arm-none-eabi

# macOS
brew install arm-none-eabi-gcc
#+end_src

验证:

#+begin_src bash
arm-none-eabi-gcc --version
# arm-none-eabi-gcc (GNU Arm Embedded Toolchain 13.2.Rel1) 13.2.0
#+end_src

**** 链接脚本 (Linker Script)

定义内存布局:

#+begin_src ld
/* STM32F407.ld */
MEMORY
{
  FLASH (rx)  : ORIGIN = 0x08000000, LENGTH = 1024K
  SRAM (rwx)  : ORIGIN = 0x20000000, LENGTH = 192K
}

SECTIONS
{
  .text : {
    KEEP(*(.isr_vector))  /* 中断向量表 */
    *(.text*)
    *(.rodata*)
  } > FLASH

  .data : {
    _sdata = .;
    *(.data*)
    _edata = .;
  } > SRAM AT > FLASH

  .bss : {
    _sbss = .;
    *(.bss*)
    *(COMMON)
    _ebss = .;
  } > SRAM
}
#+end_src

**** Makefile 示例

#+begin_src makefile
# Makefile
TARGET = firmware
SRCS = main.c startup.c system.c
OBJS = $(SRCS:.c=.o)

CC = arm-none-eabi-gcc
OBJCOPY = arm-none-eabi-objcopy
SIZE = arm-none-eabi-size

CFLAGS = -mcpu=cortex-m4 -mthumb -mfloat-abi=hard -mfpu=fpv4-sp-d16
CFLAGS += -O2 -g -Wall
CFLAGS += -DSTM32F407xx

LDFLAGS = -T STM32F407.ld -nostartfiles

all: $(TARGET).elf $(TARGET).bin

$(TARGET).elf: $(OBJS)
	$(CC) $(CFLAGS) $(LDFLAGS) $^ -o $@
	$(SIZE) $@

$(TARGET).bin: $(TARGET).elf
	$(OBJCOPY) -O binary $< $@

%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

flash: $(TARGET).bin
	openocd -f interface/stlink.cfg -f target/stm32f4x.cfg \
	  -c "program $(TARGET).bin 0x08000000 verify reset exit"

clean:
	rm -f $(OBJS) $(TARGET).elf $(TARGET).bin
#+end_src

** 2. 编写代码

*** 启动代码 (Startup Code)

=startup.c= 负责:

1. *初始化中断向量表*
2. *复制 =.data= 段* (从 Flash 到 SRAM)
3. *清零 =.bss= 段*
4. *调用 =main()=*

#+begin_src c
// startup.c (简化版)
extern unsigned long _sdata, _edata, _sidata;
extern unsigned long _sbss, _ebss;
extern int main(void);

void Reset_Handler(void) {
    unsigned long *src, *dst;

    // 复制 .data 段
    src = &_sidata;
    for (dst = &_sdata; dst < &_edata; ) {
        *dst++ = *src++;
    }

    // 清零 .bss 段
    for (dst = &_sbss; dst < &_ebss; ) {
        *dst++ = 0;
    }

    // 调用 main
    main();

    // 如果 main 返回, 进入死循环
    while (1);
}

// 中断向量表
__attribute__((section(".isr_vector")))
void (* const vectors[])(void) = {
    (void (*)(void))((unsigned long)&_estack),  // 初始栈指针
    Reset_Handler,
    NMI_Handler,
    HardFault_Handler,
    // ...
};
#+end_src

*** 应用代码

#+begin_src c
// main.c
#include "stm32f4xx.h"

void delay_ms(uint32_t ms) {
    for (uint32_t i = 0; i < ms * 8000; i++) {
        __NOP();  // 粗略延时
    }
}

int main(void) {
    // 使能 GPIOA 时钟
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;

    // 配置 PA5 为推挽输出
    GPIOA->MODER &= ~(0x3 << (5*2));
    GPIOA->MODER |= (0x1 << (5*2));

    while (1) {
        GPIOA->BSRR = (1 << 5);      // 点亮 LED
        delay_ms(500);
        GPIOA->BSRR = (1 << (5+16)); // 熄灭 LED
        delay_ms(500);
    }

    return 0;
}
#+end_src

** 3. 编译和烧录

#+begin_src bash
# 编译
make

# 查看大小
arm-none-eabi-size firmware.elf
#    text    data     bss     dec     hex filename
#    2048     100    1024    3172     c64 firmware.elf

# 烧录
make flash
#+end_src

** 4. 调试

*** GDB + OpenOCD

启动 OpenOCD:

#+begin_src bash
openocd -f interface/stlink.cfg -f target/stm32f4x.cfg
# Open On-Chip Debugger 0.12.0
# Info : Listening on port 3333 for gdb connections
#+end_src

连接 GDB:

#+begin_src bash
arm-none-eabi-gdb firmware.elf
(gdb) target extended-remote :3333
(gdb) monitor reset halt
(gdb) load
(gdb) break main
(gdb) continue
#+end_src

*** 常用 GDB 命令

#+begin_src gdb
# 单步执行
(gdb) step

# 继续执行
(gdb) continue

# 查看寄存器
(gdb) info registers

# 读取内存
(gdb) x/10wx 0x20000000

# 查看调用栈
(gdb) backtrace

# 设置断点
(gdb) break main.c:42

# 查看变量
(gdb) print my_variable
#+end_src

** 5. 高级调试: RTT (Real-Time Transfer)

SEGGER RTT 允许 *实时打印日志*，无需 UART:

#+begin_src c
#include "SEGGER_RTT.h"

int main(void) {
    SEGGER_RTT_printf(0, "Hello, RTT!\n");

    int counter = 0;
    while (1) {
        SEGGER_RTT_printf(0, "Counter: %d\n", counter++);
        delay_ms(1000);
    }
}
#+end_src

查看输出:

#+begin_src bash
# J-Link RTT Viewer
JLinkRTTViewer

# 或 telnet
telnet localhost 19021
#+end_src

*优势*:

- 速度极快 (> 1 MB/s)
- 无需占用 UART
- 支持双向通信

* 总结: Cortex-M 开发的最佳实践

** 工具链选择

| 需求        | 推荐方案                  |
|-------------+--------------------------|
| 快速上手     | STM32CubeIDE + HAL       |
| 完全控制     | GCC + Makefile + OpenOCD |
| 专业开发     | Keil MDK / IAR EW        |
| 跨平台 + 开源 | VS Code + CMake + pyOCD  |

** 调试器选择

| 场景       | 推荐设备                 |
|------------+-------------------------|
| 预算有限    | DAPLink (¥30~50)        |
| 专业开发    | J-Link (¥2,000+)        |
| STM32 专用 | ST-Link/V3 (¥300)       |
| 完全开源    | Black Magic Probe (¥50) |

** 代码风格

- *避免魔法数字*: 用 HAL 或寄存器宏，不要直接写 =0x40020000=
- *使用 CMSIS*: 标准化的中断、延时、位操作
- *模块化*: 驱动、应用、BSP 分离
- *版本控制*: Git + =.gitignore= (排除 =build/=, =*.o=)

** 调试技巧

- *硬件断点*: Cortex-M4 有 6 个硬件断点，比软件断点快
- *SWO 输出*: 比 UART 快，适合高速打印
- *RTT*: 实时日志，无需 UART
- *Fault 分析*: 读取 CFSR (Configurable Fault Status Register) 定位崩溃原因

** 避免的坑

- *时钟未初始化*: 导致外设不工作
- *上拉/下拉配置错误*: GPIO 浮空导致误触发
- *中断优先级冲突*: 高优先级中断抢占导致死锁
- *栈溢出*: 递归过深或局部变量过大
- *Flash 写入未擦除*: Flash 只能从 1 写成 0，不能从 0 写成 1

*永远记住*: 嵌入式开发的核心是 *理解硬件*​，而不是盲目调用库函数。读 Datasheet, Reference Manual，用逻辑分析仪验证信号，是成为高手的必经之路。
